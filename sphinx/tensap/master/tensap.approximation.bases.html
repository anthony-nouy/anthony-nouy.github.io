
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>tensap.approximation.bases package &#8212; tensap 1.1 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="tensap.approximation.integration package" href="tensap.approximation.integration.html" />
    <link rel="prev" title="tensap.approximation package" href="tensap.approximation.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="tensap-approximation-bases-package">
<h1>tensap.approximation.bases package<a class="headerlink" href="#tensap-approximation-bases-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-tensap.approximation.bases.full_tensor_product_functional_basis">
<span id="tensap-approximation-bases-full-tensor-product-functional-basis-module"></span><h2>tensap.approximation.bases.full_tensor_product_functional_basis module<a class="headerlink" href="#module-tensap.approximation.bases.full_tensor_product_functional_basis" title="Permalink to this headline">¶</a></h2>
<p>Module full_tensor_product_functional_basis.</p>
<dl class="py class">
<dt id="tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis">
<em class="property">class </em><code class="sig-prename descclassname">tensap.approximation.bases.full_tensor_product_functional_basis.</code><code class="sig-name descname">FullTensorProductFunctionalBasis</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">bases</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#tensap.approximation.bases.functional_basis.FunctionalBasis" title="tensap.approximation.bases.functional_basis.FunctionalBasis"><code class="xref py py-class docutils literal notranslate"><span class="pre">tensap.approximation.bases.functional_basis.FunctionalBasis</span></code></a></p>
<p>Class FullTensorProductFunctionalBasis.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>bases</strong><span class="classifier">list or tensap.FunctionalBases</span></dt><dd><p>The bases associated with the object.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">adaptation_path</span></code>()</p></td>
<td><p>Return the adaptation path of the functional basis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.cardinal" title="tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.cardinal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cardinal</span></code></a>()</p></td>
<td><p>Return the number of basis functions.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.conditional_expectation" title="tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.conditional_expectation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">conditional_expectation</span></code></a>(dims, *args)</p></td>
<td><p>Compute the conditional expectation of self with respect to the random variables dims (a subset of range(d)).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.domain" title="tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.domain"><code class="xref py py-obj docutils literal notranslate"><span class="pre">domain</span></code></a>()</p></td>
<td><p>Return the domain of the set of basis functions, which is the support of the associated measure.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.eval" title="tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.eval"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval</span></code></a>(x)</p></td>
<td><p>Return the evaluation of the basis functions at the points x.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">expectation</span></code>()</p></td>
<td><p>Return the expectation of the basis functions.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.gram_matrix" title="tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.gram_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gram_matrix</span></code></a>([dims])</p></td>
<td><p>Return the gram matrix of each basis of self, or of a selection of them if dims is provided.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">interpolate</span></code>(y[, x])</p></td>
<td><p>Provide an interpolation on a functional basis of a function (or values of the function) y associated with a set of n interpolation points x.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.interpolation_points" title="tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.interpolation_points"><code class="xref py py-obj docutils literal notranslate"><span class="pre">interpolation_points</span></code></a>(*args)</p></td>
<td><p>Return the interpolation points for the basis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.keep_bases" title="tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.keep_bases"><code class="xref py py-obj docutils literal notranslate"><span class="pre">keep_bases</span></code></a>(ind)</p></td>
<td><p>Keep only the bases of self of index ind.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">kron</span></code>()</p></td>
<td><p>Compute the Kronecker product of two bases.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.length" title="tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.length"><code class="xref py py-obj docutils literal notranslate"><span class="pre">length</span></code></a>()</p></td>
<td><p>Return the number of bases in self.bases.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">magic_points</span></code>([x, J])</p></td>
<td><p>Provide the magic points associated with a functional basis f selected in a given set of points x.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.mean" title="tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean</span></code></a>(*args)</p></td>
<td><p>Return the mean of the basis functions.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.ndim" title="tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.ndim"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndim</span></code></a>()</p></td>
<td><p>Return the dimension n for f defined in R^n.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.orthonormalize" title="tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.orthonormalize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">orthonormalize</span></code></a>()</p></td>
<td><p>Orthonormalize the basis.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot</span></code>([indices, n])</p></td>
<td><p>Plot the functions of the basis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.projection" title="tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.projection"><code class="xref py py-obj docutils literal notranslate"><span class="pre">projection</span></code></a>(fun, I)</p></td>
<td><p>Compute the projection of the function fun on the basis functions of self.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">random</span></code>([n, measure])</p></td>
<td><p>Evaluate the basis using n points drawn randomly according to measure if provided, or to self.measure otherwise.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.remove_bases" title="tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.remove_bases"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_bases</span></code></a>(ind)</p></td>
<td><p>Remove bases of self of index ind.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">storage</span></code>()</p></td>
<td><p>Return the storage requirement of the FunctionalBasis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.tensor_product_interpolation" title="tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.tensor_product_interpolation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tensor_product_interpolation</span></code></a>(fun[, grid])</p></td>
<td><p>Return the interpolation of function fun on a product grid.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.transpose" title="tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.transpose"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transpose</span></code></a>(perm)</p></td>
<td><p>Return self with the basis permutation perm.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 74%" />
<col style="width: 26%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>christoffel</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>keep_mapping</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>optimal_sampling_measure</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>remove_mapping</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.cardinal">
<code class="sig-name descname">cardinal</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.cardinal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of basis functions.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>int</dt><dd><p>The number of basis functions.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.conditional_expectation">
<code class="sig-name descname">conditional_expectation</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dims</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.conditional_expectation" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the conditional expectation of self with respect to
the random variables dims (a subset of range(d)). The expectation
with respect to other variables (in the complementary set of
dims) is taken with respect to the probability measure given by
tensap.RandomVector XdimsC if provided, or with respect to the
probability measure associated with the corresponding bases of
the function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>The dimensions in which the expectation is computed.</p>
</dd>
<dt><strong>XdimsC: tensap.RandomVector, optional</strong></dt><dd><p>The random vector used for the computation of the conditional
expectation. The default is None, indicating to use the</p>
</dd>
<dt><strong>probability measure associated with the basis.</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>f</strong><span class="classifier">tensap.FunctionalBasisArray</span></dt><dd><p>The conditional expectation of the function.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.domain">
<code class="sig-name descname">domain</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.domain" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the domain of the set of basis functions, which is the support
of the associated measure.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>The domain of the set of basis functions</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.eval">
<code class="sig-name descname">eval</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the evaluation of the basis functions at the points x.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">list or numpy.ndarray</span></dt><dd><p>The points at which the basis functions are to be evaluted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>The evaluations of the basis functions at the points x.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.gram_matrix">
<code class="sig-name descname">gram_matrix</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dims</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.gram_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the gram matrix of each basis of self, or of a selection of
them if dims is provided.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list or numpy.ndarray, optional</span></dt><dd><p>The dimensions of the bases for which the gram matrix is computed.
The default is None, indicating all the bases.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>list</dt><dd><p>The gram matrix of the selected bases.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.interpolation_points">
<code class="sig-name descname">interpolation_points</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.interpolation_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the interpolation points for the basis.</p>
<p>See also FunctionalBasis.magic_points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>*args</strong><span class="classifier">tuple</span></dt><dd><p>The inputs arguments of the method FunctionalBasis.magic_points.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>The interpolation points for the basis.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.keep_bases">
<code class="sig-name descname">keep_bases</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ind</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.keep_bases" title="Permalink to this definition">¶</a></dt>
<dd><p>Keep only the bases of self of index ind.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ind</strong><span class="classifier">int or list or numpy.ndarray</span></dt><dd><p>The indices of the bases to keep.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>tensap.FullTensorProductFunctionalBasis</dt><dd><p>The FullTensorProductFunctionalBasis with kept bases.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.keep_mapping">
<code class="sig-name descname">keep_mapping</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ind</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.keep_mapping" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.length">
<code class="sig-name descname">length</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.length" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of bases in self.bases.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>int</dt><dd><p>The number of bases in self.bases.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.mean">
<code class="sig-name descname">mean</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the mean of the basis functions.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>The mean of the basis functions.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.ndim">
<code class="sig-name descname">ndim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.ndim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dimension n for f defined in R^n.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>int</dt><dd><p>The dimension n for f defined in R^n.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.optimal_sampling_measure">
<code class="sig-name descname">optimal_sampling_measure</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.optimal_sampling_measure" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.orthonormalize">
<code class="sig-name descname">orthonormalize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.orthonormalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Orthonormalize the basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>out</strong><span class="classifier">tensap.SubFunctionalBasis</span></dt><dd><p>The orthonormalized basis.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.projection">
<code class="sig-name descname">projection</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fun</span></em>, <em class="sig-param"><span class="n">I</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.projection" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the projection of the function fun on the basis functions of
self.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fun</strong><span class="classifier">tensap.Function</span></dt><dd><p>The function to project.</p>
</dd>
<dt><strong>I</strong><span class="classifier">tensap.IntegrationRule</span></dt><dd><p>The integration rule used to compute the projection.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>tensap.FunctionalTensor</dt><dd><p>The projection of the function fun on the basis functions of self.</p>
</dd>
<dt><strong>output</strong><span class="classifier">dict</span></dt><dd><p>Dictionnary containing the number of evaluations of the function in
the key ‘number_of_evaluations’.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>NotImplementedError</dt><dd><p>If the provided integration rule is not a
tensap.FullTensorProductIntegrationRule.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.remove_bases">
<code class="sig-name descname">remove_bases</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ind</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.remove_bases" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove bases of self of index ind.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ind</strong><span class="classifier">int or list or numpy.ndarray</span></dt><dd><p>The indices of the bases to remove.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>tensap.FullTensorProductFunctionalBasis</dt><dd><p>The FullTensorProductFunctionalBasis with removed bases.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.remove_mapping">
<code class="sig-name descname">remove_mapping</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ind</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.remove_mapping" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.tensor_product_interpolation">
<code class="sig-name descname">tensor_product_interpolation</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fun</span></em>, <em class="sig-param"><span class="n">grid</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.tensor_product_interpolation" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the interpolation of function fun on a product grid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fun</strong><span class="classifier">function or tensap.Function or tensap.Tensor</span></dt><dd><p>The function to interpolate, or a tensor of order d whose entries
are the evaluations of the function on a product grid.</p>
</dd>
<dt><strong>grid</strong><span class="classifier">list, optional</span></dt><dd><p>The grid of points used for the interpolation. If one grid has more
points than the dimension of the corresponding basis, use
magicPoints for the selection of a subset of points adapted to the
basis. The default is None, indicating to use the method
self.bases.interpolation_points().</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>tensap.FunctionalTensor</dt><dd><p>The interpolation of the function.</p>
</dd>
<dt><strong>output</strong><span class="classifier">dict</span></dt><dd><p>A dictionnary of outputs of the method.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If the argument fun is neither a tensap.Function, a function nor
a tensap.Tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.transpose">
<code class="sig-name descname">transpose</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">perm</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.full_tensor_product_functional_basis.FullTensorProductFunctionalBasis.transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self with the basis permutation perm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>perm</strong><span class="classifier">list or numpy.ndarray</span></dt><dd><p>The permutation of the bases.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>tensap.FullTensorProductFunctionalBasis</dt><dd><p>The FullTensorProductFunctionalBasis with permuted bases.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-tensap.approximation.bases.functional_bases">
<span id="tensap-approximation-bases-functional-bases-module"></span><h2>tensap.approximation.bases.functional_bases module<a class="headerlink" href="#module-tensap.approximation.bases.functional_bases" title="Permalink to this headline">¶</a></h2>
<p>Module functional_bases.</p>
<dl class="py class">
<dt id="tensap.approximation.bases.functional_bases.FunctionalBases">
<em class="property">class </em><code class="sig-prename descclassname">tensap.approximation.bases.functional_bases.</code><code class="sig-name descname">FunctionalBases</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">bases</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_bases.FunctionalBases" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Class FunctionalBases.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>bases</strong><span class="classifier">list or numpy.ndarray, or tensap.FunctionalBases, optional</span></dt><dd><p>List or numpy.ndarray containing objects of type FunctionalBasis.
The default is None.</p>
</dd>
<dt><strong>measure</strong><span class="classifier">tensap.Measure</span></dt><dd><p>The measure associated with the functional bases. By default, a
tensap.ProductMeasure constituted of the attribute measure of each
basis of bases.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_bases.FunctionalBases.adaptation_path" title="tensap.approximation.bases.functional_bases.FunctionalBases.adaptation_path"><code class="xref py py-obj docutils literal notranslate"><span class="pre">adaptation_path</span></code></a>()</p></td>
<td><p>Compute the adaptationPath for each basis in self.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_bases.FunctionalBases.cardinals" title="tensap.approximation.bases.functional_bases.FunctionalBases.cardinals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cardinals</span></code></a>([ind])</p></td>
<td><p>Return the number of functions in each basis of self, or in basis ind if provided.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_bases.FunctionalBases.derivative" title="tensap.approximation.bases.functional_bases.FunctionalBases.derivative"><code class="xref py py-obj docutils literal notranslate"><span class="pre">derivative</span></code></a>(n)</p></td>
<td><p>Compute the n-derivative of the basis functions of self.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_bases.FunctionalBases.domain" title="tensap.approximation.bases.functional_bases.FunctionalBases.domain"><code class="xref py py-obj docutils literal notranslate"><span class="pre">domain</span></code></a>()</p></td>
<td><p>Return the domain of each basis of self.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_bases.FunctionalBases.duplicate" title="tensap.approximation.bases.functional_bases.FunctionalBases.duplicate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">duplicate</span></code></a>(basis, dim)</p></td>
<td><p>Create a FunctionalBases with bases created with a duplication of basis d times.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_bases.FunctionalBases.eval" title="tensap.approximation.bases.functional_bases.FunctionalBases.eval"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval</span></code></a>(x[, dims, nargout])</p></td>
<td><p>Computes evaluations of the basis functions of self at points x in dimensions dims if provided, in all the dimensions if not.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_bases.FunctionalBases.eval_derivative" title="tensap.approximation.bases.functional_bases.FunctionalBases.eval_derivative"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval_derivative</span></code></a>(n, x[, dims, nargout])</p></td>
<td><p>Compute evaluations of the n-derivative of the basis functions of</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_bases.FunctionalBases.get_random_vector" title="tensap.approximation.bases.functional_bases.FunctionalBases.get_random_vector"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_random_vector</span></code></a>()</p></td>
<td><p>Returns the random vector associated with self.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_bases.FunctionalBases.gram_matrix" title="tensap.approximation.bases.functional_bases.FunctionalBases.gram_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gram_matrix</span></code></a>([dims])</p></td>
<td><p>Return the gram matrix of each basis of self, or of a selection of them if dims is provided.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_bases.FunctionalBases.interpolation_points" title="tensap.approximation.bases.functional_bases.FunctionalBases.interpolation_points"><code class="xref py py-obj docutils literal notranslate"><span class="pre">interpolation_points</span></code></a>([x])</p></td>
<td><p>Return the interpolation points for the bases.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_bases.FunctionalBases.keep_bases" title="tensap.approximation.bases.functional_bases.FunctionalBases.keep_bases"><code class="xref py py-obj docutils literal notranslate"><span class="pre">keep_bases</span></code></a>(ind)</p></td>
<td><p>Keep only the bases of self of index ind.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_bases.FunctionalBases.kron" title="tensap.approximation.bases.functional_bases.FunctionalBases.kron"><code class="xref py py-obj docutils literal notranslate"><span class="pre">kron</span></code></a>(g)</p></td>
<td><p>Return the bases obtained by the Kronecker product of two bases.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_bases.FunctionalBases.length" title="tensap.approximation.bases.functional_bases.FunctionalBases.length"><code class="xref py py-obj docutils literal notranslate"><span class="pre">length</span></code></a>()</p></td>
<td><p>Return the number of bases in self.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_bases.FunctionalBases.magic_points" title="tensap.approximation.bases.functional_bases.FunctionalBases.magic_points"><code class="xref py py-obj docutils literal notranslate"><span class="pre">magic_points</span></code></a>(x[, J])</p></td>
<td><p>Provide the magic points associated with the functional bases selected in a given set of points x.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_bases.FunctionalBases.mean" title="tensap.approximation.bases.functional_bases.FunctionalBases.mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean</span></code></a>([dims, measure])</p></td>
<td><p>Compute the mean of self in the dimensions in dims according to the RandomVector measure if provided, or to the standard RandomVector associated with each basis if not.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_bases.FunctionalBases.ndim" title="tensap.approximation.bases.functional_bases.FunctionalBases.ndim"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndim</span></code></a>()</p></td>
<td><p>Return the dimension of each basis of self.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_bases.FunctionalBases.one" title="tensap.approximation.bases.functional_bases.FunctionalBases.one"><code class="xref py py-obj docutils literal notranslate"><span class="pre">one</span></code></a>([dims])</p></td>
<td><p>Return the coefficients associated with the FunctionalBases so that it returns one.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_bases.FunctionalBases.orthonormalize" title="tensap.approximation.bases.functional_bases.FunctionalBases.orthonormalize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">orthonormalize</span></code></a>()</p></td>
<td><p>Orthonormalize the basis functions of self.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_bases.FunctionalBases.random" title="tensap.approximation.bases.functional_bases.FunctionalBases.random"><code class="xref py py-obj docutils literal notranslate"><span class="pre">random</span></code></a>(*args, **kwargs)</p></td>
<td><p>Compute random evaluations of the bases in self.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_bases.FunctionalBases.random_dims" title="tensap.approximation.bases.functional_bases.FunctionalBases.random_dims"><code class="xref py py-obj docutils literal notranslate"><span class="pre">random_dims</span></code></a>(dims[, n, measure, nargout])</p></td>
<td><p>Evaluate the bases in dimensions dims of the bases of self using n points drawn randomly according to measure if provided, or to self.measure.marginal(dims) otherwise.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_bases.FunctionalBases.remove_bases" title="tensap.approximation.bases.functional_bases.FunctionalBases.remove_bases"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_bases</span></code></a>(ind)</p></td>
<td><p>Remove bases of self of index ind.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_bases.FunctionalBases.storage" title="tensap.approximation.bases.functional_bases.FunctionalBases.storage"><code class="xref py py-obj docutils literal notranslate"><span class="pre">storage</span></code></a>()</p></td>
<td><p>Return the storage requirement of the FunctionalBases.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_bases.FunctionalBases.tensor_product_interpolation" title="tensap.approximation.bases.functional_bases.FunctionalBases.tensor_product_interpolation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tensor_product_interpolation</span></code></a>(*args)</p></td>
<td><p>Interpolate a function on a product grid.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_bases.FunctionalBases.transpose" title="tensap.approximation.bases.functional_bases.FunctionalBases.transpose"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transpose</span></code></a>(perm)</p></td>
<td><p>Return self with the basis permutation perm.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="tensap.approximation.bases.functional_bases.FunctionalBases.adaptation_path">
<code class="sig-name descname">adaptation_path</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_bases.FunctionalBases.adaptation_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the adaptationPath for each basis in self.</p>
<p>See also tensap.FunctionalBasis.adaptation_path.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>list</dt><dd><p>List of adaptation paths for each basis.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_bases.FunctionalBases.cardinals">
<code class="sig-name descname">cardinals</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ind</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_bases.FunctionalBases.cardinals" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of functions in each basis of self, or in basis ind
if provided.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ind</strong><span class="classifier">ind, optional</span></dt><dd><p>The index of the selected basis. The default is None.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>The number of functions in each basis of self, or in basis ind
if provided.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_bases.FunctionalBases.derivative">
<code class="sig-name descname">derivative</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_bases.FunctionalBases.derivative" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the n-derivative of the basis functions of self.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n</strong><span class="classifier">list or numpy.ndarray</span></dt><dd><p>The order of derivation in each dimension.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">FunctionalBases</span></dt><dd><p>A Functionalbases with the n-derivative of the basis functions of
self.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_bases.FunctionalBases.domain">
<code class="sig-name descname">domain</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_bases.FunctionalBases.domain" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the domain of each basis of self.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>list</dt><dd><p>The domain of each basis of self.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_bases.FunctionalBases.duplicate">
<em class="property">static </em><code class="sig-name descname">duplicate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">basis</span></em>, <em class="sig-param"><span class="n">dim</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_bases.FunctionalBases.duplicate" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a FunctionalBases with bases created with a duplication of
basis d times.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>basis</strong><span class="classifier">tensap.FunctionalBasis</span></dt><dd><p>The basis to be duplicated.</p>
</dd>
<dt><strong>dim</strong><span class="classifier">int</span></dt><dd><p>The number of times basis is duplicated.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>tensap.FunctionalBases</dt><dd><p>The obtained FunctionalBases.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_bases.FunctionalBases.eval">
<code class="sig-name descname">eval</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">dims</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">nargout</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_bases.FunctionalBases.eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes evaluations of the basis functions of self at points x
in dimensions dims if provided, in all the dimensions if not.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>The input points.</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list or numpy.ndarray, optional</span></dt><dd><p>The dimensions of the bases to be evaluated. The default is None,
indicating all the dimensions.</p>
</dd>
<dt><strong>nargout</strong><span class="classifier">int, optional</span></dt><dd><p>Indicates the number of expected outputs. The default is 1,
indicating to return only the evaluations of the basis functions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">list</span></dt><dd><p>Evaluations of the basis functions of self.</p>
</dd>
<dt><strong>x</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>The input points, grouped by basis.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_bases.FunctionalBases.eval_derivative">
<code class="sig-name descname">eval_derivative</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span></em>, <em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">dims</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">nargout</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_bases.FunctionalBases.eval_derivative" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Compute evaluations of the n-derivative of the basis functions of
self at points x in each dimension in dims if provided, in all the
dimensions otherwise.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n</strong><span class="classifier">list or numpy.ndarray</span></dt><dd><p>The order of derivation in each dimension (in dims if provided).</p>
</dd>
<dt><strong>x</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>The input points.</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list or numpy.ndarray, optional</span></dt><dd><p>The dimensions of the bases for which the n-derivative is to be
computed. The default is None, indicating all the dimensions.</p>
</dd>
<dt><strong>nargout</strong><span class="classifier">int, optional</span></dt><dd><p>Indicates the number of expected outputs. The default is 1,
indicating to return only the evaluations of the n-derivative of
the basis functions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">list</span></dt><dd><p>Evaluations of the n-derivative of the basis functions of self.</p>
</dd>
<dt><strong>x</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>The input points, grouped by basis.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_bases.FunctionalBases.get_random_vector">
<code class="sig-name descname">get_random_vector</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_bases.FunctionalBases.get_random_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the random vector associated with self.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>measure</strong><span class="classifier">tensap.RandomVector</span></dt><dd><p>The random vector associated with self.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_bases.FunctionalBases.gram_matrix">
<code class="sig-name descname">gram_matrix</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dims</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_bases.FunctionalBases.gram_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the gram matrix of each basis of self, or of a selection of
them if dims is provided.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list or numpy.ndarray, optional</span></dt><dd><p>The dimensions of the bases for which the gram matrix is computed.
The default is None, indicating all the bases.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>list</dt><dd><p>The gram matrix of the selected bases.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_bases.FunctionalBases.interpolation_points">
<code class="sig-name descname">interpolation_points</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_bases.FunctionalBases.interpolation_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the interpolation points for the bases.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">tensap.FullTensorGrid or list or numpy.ndarray</span></dt><dd><p>The set of points in which the interpolation points are selected.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>points</strong><span class="classifier">list</span></dt><dd><p>The interpolation points.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_bases.FunctionalBases.keep_bases">
<code class="sig-name descname">keep_bases</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ind</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_bases.FunctionalBases.keep_bases" title="Permalink to this definition">¶</a></dt>
<dd><p>Keep only the bases of self of index ind.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ind</strong><span class="classifier">int or list or numpy.ndarray</span></dt><dd><p>The indices of the bases to keep.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">tensap.FunctionalBases</span></dt><dd><p>The FunctionalBases with kept bases.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_bases.FunctionalBases.kron">
<code class="sig-name descname">kron</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">g</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_bases.FunctionalBases.kron" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bases obtained by the Kronecker product of two bases.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>g</strong><span class="classifier">FunctionalBases</span></dt><dd><p>The second bases of the product.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">FunctionalBases</span></dt><dd><p>The bases obtained by the Kronecker product of two bases.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_bases.FunctionalBases.length">
<code class="sig-name descname">length</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_bases.FunctionalBases.length" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of bases in self.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>int</dt><dd><p>The number of bases in self.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_bases.FunctionalBases.magic_points">
<code class="sig-name descname">magic_points</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">J</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_bases.FunctionalBases.magic_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide the magic points associated with the functional bases selected
in a given set of points x.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">tensap.FullTensorGrid or list or numpy.ndarray</span></dt><dd><p>The set of points in which the magic points are selected.</p>
</dd>
<dt><strong>J</strong><span class="classifier">numpy.ndarray, optional</span></dt><dd><p>The default is None. If not none, selected the magic indices with
tensap.magic_indices(F[:, J], self.cardinal(), ‘left’)[0]</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>points</strong><span class="classifier">list</span></dt><dd><p>The magic points associated with each basis of self.</p>
</dd>
<dt><strong>ind</strong><span class="classifier">list</span></dt><dd><p>The locations of the magic points in x for each basis of self.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_bases.FunctionalBases.mean">
<code class="sig-name descname">mean</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dims</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">measure</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_bases.FunctionalBases.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the mean of self in the dimensions in dims according to
the RandomVector measure if provided, or to the standard RandomVector
associated with each basis if not.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list or numpy.ndarray, optional</span></dt><dd><p>The dimensions of the bases for which the mean is to be computed.
The default is None, indicating all the bases.</p>
</dd>
<dt><strong>measure</strong><span class="classifier">tensap.RandomVector or tensap.RandomVariable, optional</span></dt><dd><p>The probability measure according to which the mean is computed.
The default is None, indicating to use the self.measure.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">list</span></dt><dd><p>The mean of each basis functions.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_bases.FunctionalBases.ndim">
<code class="sig-name descname">ndim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_bases.FunctionalBases.ndim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dimension of each basis of self.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>list</dt><dd><p>The dimension of each basis of self.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_bases.FunctionalBases.one">
<code class="sig-name descname">one</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dims</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_bases.FunctionalBases.one" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the coefficients associated with the FunctionalBases so that it
returns one.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list or numpy.ndarray, optional</span></dt><dd><p>The dimensions of the bases that need to return one. The default
is None, indicating all the bases.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>list</dt><dd><p>The list of coefficients so that the selected bases return one.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_bases.FunctionalBases.orthonormalize">
<code class="sig-name descname">orthonormalize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_bases.FunctionalBases.orthonormalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Orthonormalize the basis functions of self.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>tensap.FunctionalBases</dt><dd><p>The FunctionalBases with orthonormalized basis functions.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_bases.FunctionalBases.random">
<code class="sig-name descname">random</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_bases.FunctionalBases.random" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute random evaluations of the bases in self.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>*args</strong><span class="classifier">misc</span></dt><dd><p>Additional parameters for the random generation. See random_dims.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>list or numpy.ndarray</dt><dd><p>Random evaluations of the basis functions of self.</p>
</dd>
<dt>numpy.ndarray</dt><dd><p>The input points, grouped by basis.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_bases.FunctionalBases.random_dims">
<code class="sig-name descname">random_dims</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dims</span></em>, <em class="sig-param"><span class="n">n</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">measure</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">nargout</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_bases.FunctionalBases.random_dims" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the bases in dimensions dims of the bases of self
using n points drawn randomly according to measure if provided, or to
self.measure.marginal(dims) otherwise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list or numpy.ndarray</span></dt><dd><p>The dimensions of the bases to be evaluated.</p>
</dd>
<dt><strong>n</strong><span class="classifier">int, optional</span></dt><dd><p>The number of random evaluations. The default is 1.</p>
</dd>
<dt><strong>measure</strong><span class="classifier">tensap.ProbabilityMeasure, optional</span></dt><dd><p>The probability measure used for the generation of the input
points. The default is None, indicating to use
self.measure.marginal(dims).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>bases_eval</strong><span class="classifier">list or numpy.ndarray</span></dt><dd><p>Random evaluations of the basis functions of self.</p>
</dd>
<dt><strong>x</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>The input points, grouped by basis.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_bases.FunctionalBases.remove_bases">
<code class="sig-name descname">remove_bases</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ind</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_bases.FunctionalBases.remove_bases" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove bases of self of index ind.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ind</strong><span class="classifier">int or list or numpy.ndarray</span></dt><dd><p>The indices of the bases to remove.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">tensap.FunctionalBases</span></dt><dd><p>The FunctionalBases with removed bases.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_bases.FunctionalBases.storage">
<code class="sig-name descname">storage</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_bases.FunctionalBases.storage" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the storage requirement of the FunctionalBases.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>int</dt><dd><p>The storage requirement of the FunctionalBases.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_bases.FunctionalBases.tensor_product_interpolation">
<code class="sig-name descname">tensor_product_interpolation</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_bases.FunctionalBases.tensor_product_interpolation" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate a function on a product grid.</p>
<p>See also
tensap.FullTensorProductFunctionalBasis.tensorProductInterpolation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>*args</strong><span class="classifier">tuple</span></dt><dd><p>Parameters of the method tensorProductInterpolation of
tensap.FullTensorProductFunctionalBasis.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>tensap.FunctionalTensor</dt><dd><p>The interpolation of the function on a product grid.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_bases.FunctionalBases.transpose">
<code class="sig-name descname">transpose</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">perm</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_bases.FunctionalBases.transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self with the basis permutation perm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>perm</strong><span class="classifier">list or numpy.ndarray</span></dt><dd><p>The permutation of the bases.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">tensap.FunctionalBases</span></dt><dd><p>The FunctionalBases with permuted bases.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-tensap.approximation.bases.functional_basis">
<span id="tensap-approximation-bases-functional-basis-module"></span><h2>tensap.approximation.bases.functional_basis module<a class="headerlink" href="#module-tensap.approximation.bases.functional_basis" title="Permalink to this headline">¶</a></h2>
<p>Module functional_basis.</p>
<dl class="py class">
<dt id="tensap.approximation.bases.functional_basis.FunctionalBasis">
<em class="property">class </em><code class="sig-prename descclassname">tensap.approximation.bases.functional_basis.</code><code class="sig-name descname">FunctionalBasis</code><a class="headerlink" href="#tensap.approximation.bases.functional_basis.FunctionalBasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Class FunctionalBasis.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>measure</strong><span class="classifier">tensap.Measure</span></dt><dd><p>The measure associated with the FunctionalBasis.</p>
</dd>
<dt><strong>is_orthonormal</strong><span class="classifier">bool</span></dt><dd><p>Indicates if the basis is orthonormal with respect to the associated
measure.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_basis.FunctionalBasis.adaptation_path" title="tensap.approximation.bases.functional_basis.FunctionalBasis.adaptation_path"><code class="xref py py-obj docutils literal notranslate"><span class="pre">adaptation_path</span></code></a>()</p></td>
<td><p>Return the adaptation path of the functional basis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_basis.FunctionalBasis.cardinal" title="tensap.approximation.bases.functional_basis.FunctionalBasis.cardinal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cardinal</span></code></a>()</p></td>
<td><p>Return the number of basis functions.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_basis.FunctionalBasis.conditional_expectation" title="tensap.approximation.bases.functional_basis.FunctionalBasis.conditional_expectation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">conditional_expectation</span></code></a>()</p></td>
<td><p>Compute the conditional expectation of self with respect to the random variables dims (a subset of range(d)).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_basis.FunctionalBasis.domain" title="tensap.approximation.bases.functional_basis.FunctionalBasis.domain"><code class="xref py py-obj docutils literal notranslate"><span class="pre">domain</span></code></a>()</p></td>
<td><p>Return the domain of the set of basis functions, which is the support of the associated measure.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_basis.FunctionalBasis.eval" title="tensap.approximation.bases.functional_basis.FunctionalBasis.eval"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval</span></code></a>(x)</p></td>
<td><p>Return the evaluation of the basis functions at the points x.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_basis.FunctionalBasis.expectation" title="tensap.approximation.bases.functional_basis.FunctionalBasis.expectation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">expectation</span></code></a>()</p></td>
<td><p>Return the expectation of the basis functions.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_basis.FunctionalBasis.interpolate" title="tensap.approximation.bases.functional_basis.FunctionalBasis.interpolate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">interpolate</span></code></a>(y[, x])</p></td>
<td><p>Provide an interpolation on a functional basis of a function (or values of the function) y associated with a set of n interpolation points x.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_basis.FunctionalBasis.interpolation_points" title="tensap.approximation.bases.functional_basis.FunctionalBasis.interpolation_points"><code class="xref py py-obj docutils literal notranslate"><span class="pre">interpolation_points</span></code></a>(*args)</p></td>
<td><p>Return the interpolation points for the basis.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_basis.FunctionalBasis.kron" title="tensap.approximation.bases.functional_basis.FunctionalBasis.kron"><code class="xref py py-obj docutils literal notranslate"><span class="pre">kron</span></code></a>()</p></td>
<td><p>Compute the Kronecker product of two bases.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_basis.FunctionalBasis.magic_points" title="tensap.approximation.bases.functional_basis.FunctionalBasis.magic_points"><code class="xref py py-obj docutils literal notranslate"><span class="pre">magic_points</span></code></a>([x, J])</p></td>
<td><p>Provide the magic points associated with a functional basis f selected in a given set of points x.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_basis.FunctionalBasis.mean" title="tensap.approximation.bases.functional_basis.FunctionalBasis.mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean</span></code></a>()</p></td>
<td><p>Return the mean of the basis functions.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_basis.FunctionalBasis.ndim" title="tensap.approximation.bases.functional_basis.FunctionalBasis.ndim"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndim</span></code></a>()</p></td>
<td><p>Return the dimension n for f defined in R^n.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_basis.FunctionalBasis.orthonormalize" title="tensap.approximation.bases.functional_basis.FunctionalBasis.orthonormalize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">orthonormalize</span></code></a>()</p></td>
<td><p>Orthonormalize the basis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_basis.FunctionalBasis.plot" title="tensap.approximation.bases.functional_basis.FunctionalBasis.plot"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot</span></code></a>([indices, n])</p></td>
<td><p>Plot the functions of the basis.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_basis.FunctionalBasis.projection" title="tensap.approximation.bases.functional_basis.FunctionalBasis.projection"><code class="xref py py-obj docutils literal notranslate"><span class="pre">projection</span></code></a>(fun, G)</p></td>
<td><p>Compute the projection of the function fun onto the functional basis using the integration rule G.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_basis.FunctionalBasis.random" title="tensap.approximation.bases.functional_basis.FunctionalBasis.random"><code class="xref py py-obj docutils literal notranslate"><span class="pre">random</span></code></a>([n, measure])</p></td>
<td><p>Evaluate the basis using n points drawn randomly according to measure if provided, or to self.measure otherwise.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_basis.FunctionalBasis.storage" title="tensap.approximation.bases.functional_basis.FunctionalBasis.storage"><code class="xref py py-obj docutils literal notranslate"><span class="pre">storage</span></code></a>()</p></td>
<td><p>Return the storage requirement of the FunctionalBasis.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 74%" />
<col style="width: 26%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>christoffel</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>optimal_sampling_measure</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="tensap.approximation.bases.functional_basis.FunctionalBasis.adaptation_path">
<code class="sig-name descname">adaptation_path</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_basis.FunctionalBasis.adaptation_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the adaptation path of the functional basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>Boolean array, where n is the dimension of the functional basis,
and m is the number of elements in the adaptation path,
column P[:,i] corresponds to a sparsity pattern.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_basis.FunctionalBasis.cardinal">
<em class="property">abstract </em><code class="sig-name descname">cardinal</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_basis.FunctionalBasis.cardinal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of basis functions.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>int</dt><dd><p>The number of basis functions.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_basis.FunctionalBasis.christoffel">
<code class="sig-name descname">christoffel</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_basis.FunctionalBasis.christoffel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_basis.FunctionalBasis.conditional_expectation">
<em class="property">static </em><code class="sig-name descname">conditional_expectation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_basis.FunctionalBasis.conditional_expectation" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the conditional expectation of self with respect to
the random variables dims (a subset of range(d)). The expectation
with respect to other variables (in the complementary set of
dims) is taken with respect to the probability measure given by
tensap.RandomVector XdimsC if provided, or with respect to the
probability measure associated with the corresponding bases of
the function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>The dimensions in which the expectation is computed.</p>
</dd>
<dt><strong>XdimsC: tensap.RandomVector, optional</strong></dt><dd><p>The random vector used for the computation of the conditional
expectation. The default is None, indicating to use the</p>
</dd>
<dt><strong>probability measure associated with the basis.</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>f</strong><span class="classifier">tensap.FunctionalBasisArray</span></dt><dd><p>The conditional expectation of the function.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_basis.FunctionalBasis.domain">
<code class="sig-name descname">domain</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_basis.FunctionalBasis.domain" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the domain of the set of basis functions, which is the support
of the associated measure.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>The domain of the set of basis functions</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_basis.FunctionalBasis.eval">
<em class="property">abstract </em><code class="sig-name descname">eval</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_basis.FunctionalBasis.eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the evaluation of the basis functions at the points x.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">list or numpy.ndarray</span></dt><dd><p>The points at which the basis functions are to be evaluted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>The evaluations of the basis functions at the points x.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_basis.FunctionalBasis.expectation">
<code class="sig-name descname">expectation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_basis.FunctionalBasis.expectation" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the expectation of the basis functions. Equivalent to
self.mean().</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>The expectation of the basis functions.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_basis.FunctionalBasis.interpolate">
<code class="sig-name descname">interpolate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">x</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_basis.FunctionalBasis.interpolate" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide an interpolation on a functional basis of a function (or values
of the function) y associated with a set of n interpolation points x.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>y</strong><span class="classifier">function or list or numpy.ndarray</span></dt><dd><p>The function to interpolate, or values of it.</p>
</dd>
<dt><strong>x</strong><span class="classifier">list or numpy.ndarray, optional</span></dt><dd><p>The interpolation points. The default is None, indicating to
deduce them from the basis.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>f</strong><span class="classifier">tensap.FunctionalBasisArray</span></dt><dd><p>The computed interpolation.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_basis.FunctionalBasis.interpolation_points">
<code class="sig-name descname">interpolation_points</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_basis.FunctionalBasis.interpolation_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the interpolation points for the basis.</p>
<p>See also FunctionalBasis.magic_points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>*args</strong><span class="classifier">tuple</span></dt><dd><p>The inputs arguments of the method FunctionalBasis.magic_points.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>The interpolation points for the basis.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_basis.FunctionalBasis.kron">
<em class="property">static </em><code class="sig-name descname">kron</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_basis.FunctionalBasis.kron" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Kronecker product of two bases. For two functional bases
f_i, i = 1, …, n and g_j, j = 1, …, m, return a functional basis
h_k, k = 1, …, nm.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>tensap.FunctionalBasis</dt><dd><p>The obtained basis.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_basis.FunctionalBasis.magic_points">
<code class="sig-name descname">magic_points</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">J</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_basis.FunctionalBasis.magic_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide the magic points associated with a functional basis f selected
in a given set of points x.</p>
<p>The method uses magicIndices(F,numel(f)) on the matrix F of evaluations
of f at points x.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">list or numpy.ndarray, optional</span></dt><dd><p>The points used to construct the matrix F. The default is None,
indicating to choose x automatically based on self.measure.</p>
</dd>
<dt><strong>J</strong><span class="classifier">numpy.ndarray, optional</span></dt><dd><p>The default is None. If not none, selected the magic indices with
tensap.magic_indices(F[:, J], self.cardinal(), ‘left’)[0]</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>points</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>The magic points.</p>
</dd>
<dt><strong>ind</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>The locations of the magic points in x.</p>
</dd>
<dt><strong>output</strong><span class="classifier">dict</span></dt><dd><p>A dictionnary of outputs of the method.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_basis.FunctionalBasis.mean">
<em class="property">static </em><code class="sig-name descname">mean</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_basis.FunctionalBasis.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the mean of the basis functions.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>The mean of the basis functions.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_basis.FunctionalBasis.ndim">
<em class="property">abstract </em><code class="sig-name descname">ndim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_basis.FunctionalBasis.ndim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dimension n for f defined in R^n.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>int</dt><dd><p>The dimension n for f defined in R^n.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_basis.FunctionalBasis.optimal_sampling_measure">
<code class="sig-name descname">optimal_sampling_measure</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_basis.FunctionalBasis.optimal_sampling_measure" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_basis.FunctionalBasis.orthonormalize">
<code class="sig-name descname">orthonormalize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_basis.FunctionalBasis.orthonormalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Orthonormalize the basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>out</strong><span class="classifier">tensap.SubFunctionalBasis</span></dt><dd><p>The orthonormalized basis.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_basis.FunctionalBasis.plot">
<code class="sig-name descname">plot</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">indices</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">n</span><span class="o">=</span><span class="default_value">10000</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_basis.FunctionalBasis.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the functions of the basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>indices</strong><span class="classifier">list or numpy.ndarray, optional</span></dt><dd><p>Indices of the functions to be plotted. The default is None,
indicating all the functions.</p>
</dd>
<dt><strong>n</strong><span class="classifier">int, optional</span></dt><dd><p>The number of points used for the plot. The default is 10000.</p>
</dd>
<dt><strong>*args</strong><span class="classifier">tuple</span></dt><dd><p>Additional parameters used by matplotlib.pyplot’s function plot.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_basis.FunctionalBasis.projection">
<code class="sig-name descname">projection</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fun</span></em>, <em class="sig-param"><span class="n">G</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_basis.FunctionalBasis.projection" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the projection of the function fun onto the functional basis
using the integration rule G.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fun</strong><span class="classifier">function or tensap.Function</span></dt><dd><p>The function to project.</p>
</dd>
<dt><strong>G</strong><span class="classifier">tensap.IntegrationRule</span></dt><dd><p>The integration rule used for the projection.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>tensap.FunctionalBasisArray</dt><dd><p>The projection of the function fun onto the functional basis using
the integration rule G.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_basis.FunctionalBasis.random">
<code class="sig-name descname">random</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">measure</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_basis.FunctionalBasis.random" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the basis using n points drawn randomly according to measure
if provided, or to self.measure otherwise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n</strong><span class="classifier">int, optional</span></dt><dd><p>The number of random evaluations. The default is 1.</p>
</dd>
<dt><strong>measure</strong><span class="classifier">tensap.ProbabilityMeasure, optional</span></dt><dd><p>The probability measure used for the generation of the input
points. The default is None, indicating to use self.measure.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>basis_eval</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Random evaluations of the basis functions.</p>
</dd>
<dt><strong>x</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>The input points.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_basis.FunctionalBasis.storage">
<em class="property">static </em><code class="sig-name descname">storage</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_basis.FunctionalBasis.storage" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the storage requirement of the FunctionalBasis.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>int</dt><dd><p>The storage requirement of the FunctionalBasis.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-tensap.approximation.bases.functional_basis_array">
<span id="tensap-approximation-bases-functional-basis-array-module"></span><h2>tensap.approximation.bases.functional_basis_array module<a class="headerlink" href="#module-tensap.approximation.bases.functional_basis_array" title="Permalink to this headline">¶</a></h2>
<p>Module functional_basis_array.</p>
<dl class="py class">
<dt id="tensap.approximation.bases.functional_basis_array.FunctionalBasisArray">
<em class="property">class </em><code class="sig-prename descclassname">tensap.approximation.bases.functional_basis_array.</code><code class="sig-name descname">FunctionalBasisArray</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">basis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">shape</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_basis_array.FunctionalBasisArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="tensap.functions.html#tensap.functions.function.Function" title="tensap.functions.function.Function"><code class="xref py py-class docutils literal notranslate"><span class="pre">tensap.functions.function.Function</span></code></a></p>
<p>Class FunctionalBasisArray.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">numpy.ndarray, optional</span></dt><dd><p>The coefficents of the function on the basis. The default is None.</p>
</dd>
<dt><strong>basis</strong><span class="classifier">tensap.FunctionalBasis, optional</span></dt><dd><p>The basis. The default is None.</p>
</dd>
<dt><strong>shape</strong><span class="classifier">list or numpy.ndarray, optional</span></dt><dd><p>Array such that the function is with values in
R^(shape[0] x shape[1] x …). The default is 1.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__call__</span></code>(x[, return_f])</p></td>
<td><p>Call self as a function.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.conditional_expectation" title="tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.conditional_expectation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">conditional_expectation</span></code></a>(dims, *args)</p></td>
<td><p>Compute the conditional expectation of self with respect to the random variables dims (a subset of range(d)).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.derivative" title="tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.derivative"><code class="xref py py-obj docutils literal notranslate"><span class="pre">derivative</span></code></a>(n)</p></td>
<td><p>Compute the n-derivative of the function.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.dot" title="tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.dot"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dot</span></code></a>(g[, dim])</p></td>
<td><p>Compute the dot product between the arrays self.data and g.data treated as collections of vectors.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.dot_product_expectation" title="tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.dot_product_expectation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dot_product_expectation</span></code></a>(g[, dims, measure])</p></td>
<td><p>Compute the expectation of self(X)g(X), where X is the probability measure associated with the underlying basis, or measure if provided.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.eval" title="tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.eval"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval</span></code></a>(x, *args)</p></td>
<td><p>Evaluate the function at the points x.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.eval_derivative" title="tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.eval_derivative"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval_derivative</span></code></a>(n, x)</p></td>
<td><p>Compute the n-derivative of the function at points x in R^d, with n a multi-index of size d.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval_on_tensor_grid</span></code>(x)</p></td>
<td><p>Evaluate the Function on a grid x.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.eval_with_bases_evals" title="tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.eval_with_bases_evals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval_with_bases_evals</span></code></a>(H)</p></td>
<td><p>Compute the evaluations of the function using the evaluations of the basis H.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.expectation" title="tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.expectation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">expectation</span></code></a>([measure])</p></td>
<td><p>Compute the expectation of the function, according to the measure associated with the tensap.ProbabilityMeasure measure if provided, or to the standard tensap.ProbabilityMeasure associated with each polynomial if not.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">fplot</span></code>([support, n_points])</p></td>
<td><p>Plot the function on a support using a given number of points.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.get_coefficients" title="tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.get_coefficients"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_coefficients</span></code></a>()</p></td>
<td><p>Return the coefficients of the object.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.get_random_vector" title="tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.get_random_vector"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_random_vector</span></code></a>()</p></td>
<td><p>Return the random vector associated with the basis functions of the object.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.is_random" title="tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.is_random"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_random</span></code></a>()</p></td>
<td><p>Determine if the object is random.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.matdiv" title="tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.matdiv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">matdiv</span></code></a>(v)</p></td>
<td><p>Compute the matrix multiplication of self.data with the inverse of v.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.matmul" title="tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.matmul"><code class="xref py py-obj docutils literal notranslate"><span class="pre">matmul</span></code></a>(v)</p></td>
<td><p>Compute the matrix multiplication of self.data with v.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.mean" title="tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean</span></code></a>([measure])</p></td>
<td><p>Compute the expectation of the function, according to the measure associated with the tensap.ProbabilityMeasure measure if provided, or to the standard tensap.ProbabilityMeasure associated with each polynomial if not.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.norm" title="tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.norm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">norm</span></code></a>([p])</p></td>
<td><p>Compute the p-norm of the array self.data.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.norm_expectation" title="tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.norm_expectation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">norm_expectation</span></code></a>([measure])</p></td>
<td><p>Compute the L^2 norm of self(measure).</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">partial_evaluation</span></code>(not_alpha, x_not_alpha)</p></td>
<td><p>Return the partial evaluation of a function f(x) = f(x_alpha,x_not_alpha), a function f_alpha(.) = f(., x_not_alpha) for fixed values x_not_alpha of the variables with indices not_alpha.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.projection" title="tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.projection"><code class="xref py py-obj docutils literal notranslate"><span class="pre">projection</span></code></a>(basis[, indices])</p></td>
<td><p>Projection of the object on a functional basis using multi-indices indices if provided, or the multi-indices associated with the functional basis if not.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.random" title="tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.random"><code class="xref py py-obj docutils literal notranslate"><span class="pre">random</span></code></a>([n, measure])</p></td>
<td><p>Compute evaluations of the function at an array of points of size n, drawn randomly according to the tensap.ProbabilityMeasure measure if provided, or to the standard tensap.ProbabilityMeasure associated with each polynomial if not.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.sparse_storage" title="tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.sparse_storage"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sparse_storage</span></code></a>()</p></td>
<td><p>The storage complexity of the object, taking into account the sparsity.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.std" title="tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.std"><code class="xref py py-obj docutils literal notranslate"><span class="pre">std</span></code></a>(*args)</p></td>
<td><p>Compute the standard deviation of the function, according to the measure associated with the tensap.ProbabilityMeasure measure if provided, or to the standard tensap.ProbabilityMeasure associated with each polynomial if not.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.storage" title="tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.storage"><code class="xref py py-obj docutils literal notranslate"><span class="pre">storage</span></code></a>()</p></td>
<td><p>The storage complexity of the object.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">store_eval</span></code>(x)</p></td>
<td><p>Evaluate the function, reuising previous evaluations if possible, and storing the new evaluations in self.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.sub_functional_basis" title="tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.sub_functional_basis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sub_functional_basis</span></code></a>()</p></td>
<td><p>Converts the FunctionalBasisArray into a tensap.SubFunctionalbasis.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">surf</span></code>([n])</p></td>
<td><p>Surface plot of the bivariate function.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">test_error</span></code>(g[, n, measure])</p></td>
<td><p>Compute the test error associated with the function, using a function g or some of its evaluations as a reference.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.variance" title="tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.variance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">variance</span></code></a>([measure])</p></td>
<td><p>Compute the variance of the function, according to the measure associated with the tensap.ProbabilityMeasure measure if provided, or to the standard tensap.ProbabilityMeasure associated with each polynomial if not.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.variance_conditional_expectation" title="tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.variance_conditional_expectation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">variance_conditional_expectation</span></code></a>(alpha)</p></td>
<td><p>Compute the variance of the conditional expectation of the function in dimensions in alpha.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.conditional_expectation">
<code class="sig-name descname">conditional_expectation</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dims</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.conditional_expectation" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the conditional expectation of self with respect to
the random variables dims (a subset of range(d)). The expectation
with respect to other variables (in the complementary set of
dims) is taken with respect to the probability measure given by
tensap.RandomVector XdimsC if provided, or with respect to the
probability measure associated with the corresponding bases of
the function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>The dimensions in which the expectation is computed.</p>
</dd>
<dt><strong>*args</strong><span class="classifier">tuple</span></dt><dd><p>Additional parameters. See also the method conditional_expectation
of the underlying basis.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>f</strong><span class="classifier">tensap.FunctionalBasisArray</span></dt><dd><p>The conditional expectation of the function.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.derivative">
<code class="sig-name descname">derivative</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.derivative" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the n-derivative of the function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>The derivation order.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>df</strong><span class="classifier">tensap.FunctionalBasisArray()</span></dt><dd><p>The n-derivative of the function.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.dot">
<code class="sig-name descname">dot</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">g</span></em>, <em class="sig-param"><span class="n">dim</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the dot product between the arrays self.data and g.data
treated as collections of vectors. The function calculates
the dot product of corresponding vectors along the first
array dimension whose size does not equal 1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>g</strong><span class="classifier">tensap.FunctionalBasisArray</span></dt><dd><p>The second object of the dot product.</p>
</dd>
<dt><strong>dim</strong><span class="classifier">int or list or numpy.ndarray, optional</span></dt><dd><p>The dimension along which the dot product is computed. The default
is None, indicating all the dimensions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>float or numpy.ndarray</dt><dd><p>The result of the dot product.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.dot_product_expectation">
<code class="sig-name descname">dot_product_expectation</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">g</span></em>, <em class="sig-param"><span class="n">dims</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">measure</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.dot_product_expectation" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the expectation of self(X)g(X), where X is the probability
measure associated with the underlying basis, or measure if provided.</p>
<p>For vector-valued functions of X, dims specifies the dimensions of
self and g corresponding to the RandomVector measure.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>g</strong><span class="classifier">tensap.FunctionalBasisArray</span></dt><dd><p>The second function of the product.</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list or numpy.ndarray, optional</span></dt><dd><p>The dimensions of self and g corresponding to the RandomVector
measure. The default is None.</p>
</dd>
<dt><strong>measure</strong><span class="classifier">tensap.ProbabilityMeasure, optional</span></dt><dd><p>The probability measure used for the computation of the
expectation. The default is None, indicating to use the probability
measure associated with the underlying basis.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>float or numpy.ndarray</dt><dd><p>The result of the dot product.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>NotImplementedError</dt><dd><p>If the method is not implemented.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.eval">
<code class="sig-name descname">eval</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the function at the points x.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">list or numpy.ndarray</span></dt><dd><p>The points at which the function is to be evaluated.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>The evaluations of the function at the points x.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.eval_derivative">
<code class="sig-name descname">eval_derivative</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span></em>, <em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.eval_derivative" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the n-derivative of the function at points x in R^d, with n a
multi-index of size d.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n</strong><span class="classifier">int or list or numpy.ndarray</span></dt><dd><p>The derivation order in all the dimensions, or the derivation
orders for each dimension.</p>
</dd>
<dt><strong>x</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>The points used for the evaluation of the derivative.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>The evaluation of the n-derivative of the function at the points x.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>NotImplementedError</dt><dd><p>If the method is not implemented for the basis.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.eval_with_bases_evals">
<code class="sig-name descname">eval_with_bases_evals</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">H</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.eval_with_bases_evals" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the evaluations of the function using the evaluations of the
basis H.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>H</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>The evaluations of the basis.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>The evaluations of the function.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.expectation">
<code class="sig-name descname">expectation</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">measure</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.expectation" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the expectation of the function, according to the measure
associated with the tensap.ProbabilityMeasure measure if provided, or
to the standard tensap.ProbabilityMeasure associated with each
polynomial if not.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>measure</strong><span class="classifier">tensap.ProbabilityMeasure, optional</span></dt><dd><p>The probability measure used for the computation of the
expectation. The default is None, indicating to use the standard
tensap.ProbabilityMeasure associated with each polynomial.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>The expectation of the function.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.get_coefficients">
<code class="sig-name descname">get_coefficients</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.get_coefficients" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the coefficients of the object.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>The coefficients of the object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.get_random_vector">
<code class="sig-name descname">get_random_vector</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.get_random_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the random vector associated with the basis functions of the
object.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>tensap.RandomVector</dt><dd><p>The random vector associated with the basis functions of the
object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.is_random">
<em class="property">static </em><code class="sig-name descname">is_random</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.is_random" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if the object is random.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>bool</dt><dd><p>Boolean equal to True if the object is random.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.matdiv">
<code class="sig-name descname">matdiv</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">v</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.matdiv" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the matrix multiplication of self.data with the inverse of v.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>v</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>The array used in the matrix multiplication.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>tensap.FunctionalBasisArray</dt><dd><p>The result of the matrix multiplication.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.matmul">
<code class="sig-name descname">matmul</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">v</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.matmul" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the matrix multiplication of self.data with v.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>v</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>The array used in the matrix multiplication.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>tensap.FunctionalBasisArray</dt><dd><p>The result of the matrix multiplication.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.mean">
<code class="sig-name descname">mean</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">measure</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the expectation of the function, according to the measure
associated with the tensap.ProbabilityMeasure measure if provided, or
to the standard tensap.ProbabilityMeasure associated with each
polynomial if not.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>measure</strong><span class="classifier">tensap.ProbabilityMeasure, optional</span></dt><dd><p>The probability measure used for the computation of the
expectation. The default is None, indicating to use the standard
tensap.ProbabilityMeasure associated with each polynomial.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>The expectation of the function.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.norm">
<code class="sig-name descname">norm</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">p</span><span class="o">=</span><span class="default_value">'fro'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the p-norm of the array self.data.</p>
<p>See also numpy.linalg.norm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>p</strong><span class="classifier">int or numpy.inf or -numpy.inf or string, optional</span></dt><dd><p>The order of the norm. The default is ‘fro’.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>float</dt><dd><p>The norm of self.data.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.norm_expectation">
<code class="sig-name descname">norm_expectation</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">measure</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.norm_expectation" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the L^2 norm of self(measure). If measure is not provided, use
the probability measure associated with the underlying basis of self.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>measure</strong><span class="classifier">tap.ProbabilityMeasure, optional</span></dt><dd><p>DESCRIPTION. The default is None.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>float</dt><dd><p>The L2 norm of the function.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.projection">
<code class="sig-name descname">projection</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">basis</span></em>, <em class="sig-param"><span class="n">indices</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.projection" title="Permalink to this definition">¶</a></dt>
<dd><p>Projection of the object on a functional basis using multi-indices
indices if provided, or the multi-indices associated with
the functional basis if not.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>basis</strong><span class="classifier">tensap.FunctionalBasis (tensap.FullTensorProductFunctionalBasis</span></dt><dd><p>or tensap.SparseTensorProductFunctionalBasis)
The basis used for the projection.</p>
</dd>
<dt><strong>indices</strong><span class="classifier">tensap.MultiIndices, optional</span></dt><dd><p>The multi-indices used for the projection. The default is None,
indicating to use basis.indices.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>g</strong><span class="classifier">FunctionalBasisArray</span></dt><dd><p>The obtained projection.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.random">
<code class="sig-name descname">random</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">measure</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.random" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute evaluations of the function at an array of points of size n,
drawn randomly according to the tensap.ProbabilityMeasure measure if
provided, or to the standard tensap.ProbabilityMeasure associated with
each polynomial if not.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n</strong><span class="classifier">int, optional</span></dt><dd><p>The number of random evaluations. The default is 1.</p>
</dd>
<dt><strong>measure</strong><span class="classifier">tensap.ProbabilityMeasure, optional</span></dt><dd><p>The probability measure used to draw the points of evaluation. The
default is None, indicating to use the standard
tensap.ProbabilityMeasure associated with each polynomial.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>The random evaluations of the function.</p>
</dd>
<dt>numpy.ndarray</dt><dd><p>The points used for the evaluations of the function.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.sparse_storage">
<code class="sig-name descname">sparse_storage</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.sparse_storage" title="Permalink to this definition">¶</a></dt>
<dd><p>The storage complexity of the object, taking into account the sparsity.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>int</dt><dd><p>The storage complexity of the object, taking into account the
sparsity.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.std">
<code class="sig-name descname">std</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.std" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the standard deviation of the function, according to the
measure associated with the tensap.ProbabilityMeasure measure if
provided, or to the standard tensap.ProbabilityMeasure associated with
each polynomial if not.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>measure</strong><span class="classifier">tensap.ProbabilityMeasure, optional</span></dt><dd><p>The probability measure used for the computation of the standard
deviation. The default is None, indicating to use the standard
tensap.ProbabilityMeasure associated with each polynomial.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>The standard deviation of the function.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.storage">
<code class="sig-name descname">storage</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.storage" title="Permalink to this definition">¶</a></dt>
<dd><p>The storage complexity of the object.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>int</dt><dd><p>The storage complexity of the object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.sub_functional_basis">
<code class="sig-name descname">sub_functional_basis</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.sub_functional_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts the FunctionalBasisArray into a tensap.SubFunctionalbasis.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>tensap.SubFunctionalbasis</dt><dd><p>The FunctionalBasisArray as a tensap.SubFunctionalbasis.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.variance">
<code class="sig-name descname">variance</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">measure</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.variance" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the variance of the function, according to the measure
associated with the tensap.ProbabilityMeasure measure if provided, or
to the standard tensap.ProbabilityMeasure associated with each
polynomial if not.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>measure</strong><span class="classifier">tensap.ProbabilityMeasure, optional</span></dt><dd><p>The probability measure used for the computation of the variance.
The default is None, indicating to use the standard
tensap.ProbabilityMeasure associated with each polynomial.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>The variance of the function.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.variance_conditional_expectation">
<code class="sig-name descname">variance_conditional_expectation</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">alpha</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.functional_basis_array.FunctionalBasisArray.variance_conditional_expectation" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the variance of the conditional expectation of the function in
dimensions in alpha.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>alpha</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>The dimensions in which the variance of the conditional expectation
of the function if computed.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>The variance of the conditional expectation of the function.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-tensap.approximation.bases.polynomial_functional_basis">
<span id="tensap-approximation-bases-polynomial-functional-basis-module"></span><h2>tensap.approximation.bases.polynomial_functional_basis module<a class="headerlink" href="#module-tensap.approximation.bases.polynomial_functional_basis" title="Permalink to this headline">¶</a></h2>
<p>Module polynomial_functional_basis.</p>
<dl class="py class">
<dt id="tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis">
<em class="property">class </em><code class="sig-prename descclassname">tensap.approximation.bases.polynomial_functional_basis.</code><code class="sig-name descname">PolynomialFunctionalBasis</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">basis</span></em>, <em class="sig-param"><span class="n">indices</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#tensap.approximation.bases.functional_basis.FunctionalBasis" title="tensap.approximation.bases.functional_basis.FunctionalBasis"><code class="xref py py-class docutils literal notranslate"><span class="pre">tensap.approximation.bases.functional_basis.FunctionalBasis</span></code></a></p>
<p>Class PolynomialFunctionalBasis.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>basis</strong><span class="classifier">tensap.UnivariatePolynomials</span></dt><dd><p>The polynomials associated with the basis.</p>
</dd>
<dt><strong>indices</strong><span class="classifier">list or numpy.ndarray</span></dt><dd><p>The indices of the selected polynomials.</p>
</dd>
<dt><strong>measure</strong><span class="classifier">tensap.Measure</span></dt><dd><p>The measure associated with basis.</p>
</dd>
<dt><strong>is_orthonormal</strong><span class="classifier">bool</span></dt><dd><p>Boolean equal to true, indicating that the basis is orthonormal with
respect to measure.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">adaptation_path</span></code>()</p></td>
<td><p>Return the adaptation path of the functional basis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis.cardinal" title="tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis.cardinal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cardinal</span></code></a>()</p></td>
<td><p>Return the number of basis functions.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">conditional_expectation</span></code>()</p></td>
<td><p>Compute the conditional expectation of self with respect to the random variables dims (a subset of range(d)).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis.derivative" title="tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis.derivative"><code class="xref py py-obj docutils literal notranslate"><span class="pre">derivative</span></code></a>(k[, measure])</p></td>
<td><p>Compute the k-th order derivative of the functions of the basis projected on itself.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis.domain" title="tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis.domain"><code class="xref py py-obj docutils literal notranslate"><span class="pre">domain</span></code></a>()</p></td>
<td><p>Return the domain of the set of basis functions, which is the support of the associated measure.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis.eval" title="tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis.eval"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval</span></code></a>(x)</p></td>
<td><p>Evaluate the polynomials of self.basis of degrees in self.indices at points x.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis.eval_derivative" title="tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis.eval_derivative"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval_derivative</span></code></a>(k, x)</p></td>
<td><p>Evaluate the k-th order derivative of the functions of the basis at the points x.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">expectation</span></code>()</p></td>
<td><p>Return the expectation of the basis functions.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis.gradient" title="tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis.gradient"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gradient</span></code></a>([measure])</p></td>
<td><p>Compute the first order derivative of the functions of the basis projected on itself.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis.gram_matrix" title="tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis.gram_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gram_matrix</span></code></a>([measure])</p></td>
<td><p>Compute the Gram matrix of the basis.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis.hessian" title="tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis.hessian"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hessian</span></code></a>(measure)</p></td>
<td><p>Compute the second order derivative of the functions of the basis projected on itself.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">interpolate</span></code>(y[, x])</p></td>
<td><p>Provide an interpolation on a functional basis of a function (or values of the function) y associated with a set of n interpolation points x.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">interpolation_points</span></code>(*args)</p></td>
<td><p>Return the interpolation points for the basis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis.kron" title="tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis.kron"><code class="xref py py-obj docutils literal notranslate"><span class="pre">kron</span></code></a>(q)</p></td>
<td><p>Compute the Kronecker product of two bases.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">magic_points</span></code>([x, J])</p></td>
<td><p>Provide the magic points associated with a functional basis f selected in a given set of points x.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis.mean" title="tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis.mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean</span></code></a>([measure])</p></td>
<td><p>Return the expectation of the basis functions, accorging to measure if provided, and to self.measure ortherwise.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis.ndim" title="tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis.ndim"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndim</span></code></a>()</p></td>
<td><p>Return the dimension n for f defined in R^n.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis.one" title="tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis.one"><code class="xref py py-obj docutils literal notranslate"><span class="pre">one</span></code></a>()</p></td>
<td><p>Return the coefficients associated with the basis so that it returns one.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">orthonormalize</span></code>()</p></td>
<td><p>Orthonormalize the basis.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot</span></code>([indices, n])</p></td>
<td><p>Plot the functions of the basis.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">projection</span></code>(fun, G)</p></td>
<td><p>Compute the projection of the function fun onto the functional basis using the integration rule G.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">random</span></code>([n, measure])</p></td>
<td><p>Evaluate the basis using n points drawn randomly according to measure if provided, or to self.measure otherwise.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis.random_variable" title="tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis.random_variable"><code class="xref py py-obj docutils literal notranslate"><span class="pre">random_variable</span></code></a>()</p></td>
<td><p>Return the tensap.RandomVariable associated with self if it exists.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">storage</span></code>()</p></td>
<td><p>Return the storage requirement of the FunctionalBasis.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 74%" />
<col style="width: 26%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>christoffel</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>optimal_sampling_measure</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis.cardinal">
<code class="sig-name descname">cardinal</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis.cardinal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of basis functions.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>int</dt><dd><p>The number of basis functions.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis.christoffel">
<code class="sig-name descname">christoffel</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis.christoffel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis.derivative">
<code class="sig-name descname">derivative</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">k</span></em>, <em class="sig-param"><span class="n">measure</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis.derivative" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the k-th order derivative of the functions of the basis
projected on itself.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>k</strong><span class="classifier">int</span></dt><dd><p>The order of the derivative.</p>
</dd>
<dt><strong>measure</strong><span class="classifier">tensap.Measure, optional</span></dt><dd><p>The measure used fot the projection. The default is None,
indicating to use self.measure if it is a tensap.RandomVariable.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>tensap.SubFunctionalBasis</dt><dd><p>The k-th order derivative of the functions of the basis projected
on itself.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If no Measure is provided or can be extracted from self.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis.domain">
<code class="sig-name descname">domain</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis.domain" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the domain of the set of basis functions, which is the support
of the associated measure.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>The domain of the set of basis functions</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis.eval">
<code class="sig-name descname">eval</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis.eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the polynomials of self.basis of degrees in self.indices at
points x.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">list or numpy.ndarray</span></dt><dd><p>The points at which the basis functions are to be evaluated.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>The evaluations of the polynomials of self.basis of degrees in
self.indices at points x.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis.eval_derivative">
<code class="sig-name descname">eval_derivative</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">k</span></em>, <em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis.eval_derivative" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the k-th order derivative of the functions of the basis at the
points x.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>k</strong><span class="classifier">int</span></dt><dd><p>The order of the derivative.</p>
</dd>
<dt><strong>x</strong><span class="classifier">list or numpy.ndarray</span></dt><dd><p>The points at which the k-th derivative of the basis functions are
to be evaluated.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>The evaluations of the k-th derivative of the polynomials of
self.basis of degrees in self.indices at points x.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis.gradient">
<code class="sig-name descname">gradient</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">measure</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis.gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the first order derivative of the functions of the basis
projected on itself.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>measure</strong><span class="classifier">tensap.Measure, optional</span></dt><dd><p>The measure used fot the projection. The default is None,
indicating to use self.measure if it is a tensap.RandomVariable.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>tensap.SubFunctionalBasis</dt><dd><dl class="simple">
<dt>The first order derivative of the functions of the basis projected</dt><dd><p>on itself.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis.gram_matrix">
<code class="sig-name descname">gram_matrix</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">measure</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis.gram_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Gram matrix of the basis. The Gram matrix is the matrix of
the dot products between each possible couple of basis functions. The
dot product in the dimension i is computed according to measure if
provided, or according to self.measure otherwise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>measure</strong><span class="classifier">tensap.Measure, optional</span></dt><dd><p>The measure according to which the dot product is computed. The
default is None, indicating to use self.measure.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>The Gram matrix of the basis.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>NotImplementedError</dt><dd><p>If the attribute basis of self does not have a method moment.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis.hessian">
<code class="sig-name descname">hessian</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">measure</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis.hessian" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the second order derivative of the functions of the basis
projected on itself.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>measure</strong><span class="classifier">tensap.Measure, optional</span></dt><dd><p>The measure used fot the projection. The default is None,
indicating to use self.measure if it is a tensap.RandomVariable.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>tensap.SubFunctionalBasis</dt><dd><dl class="simple">
<dt>The second order derivative of the functions of the basis projected</dt><dd><p>on itself.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis.kron">
<code class="sig-name descname">kron</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">q</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis.kron" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Kronecker product of two bases. For two functional bases
f_i, i = 1, …, n and g_j, j = 1, …, m, return a functional basis
h_k, k = 1, …, nm.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>tensap.FunctionalBasis</dt><dd><p>The obtained basis.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis.mean">
<code class="sig-name descname">mean</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">measure</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the expectation of the basis functions, accorging to measure if
provided, and to self.measure ortherwise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>measure</strong><span class="classifier">None or tensap.RandomVariable, optional</span></dt><dd><p>The measure according to which the mean is computed. The default is
None, indicating to use self.measure.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>The mean of the basis functions.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis.ndim">
<code class="sig-name descname">ndim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis.ndim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dimension n for f defined in R^n.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>int</dt><dd><p>The dimension n for f defined in R^n.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis.one">
<code class="sig-name descname">one</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis.one" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the coefficients associated with the basis so that it returns
one.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>list</dt><dd><p>The list of coefficients so that the basis returns one.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis.optimal_sampling_measure">
<code class="sig-name descname">optimal_sampling_measure</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis.optimal_sampling_measure" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis.random_variable">
<code class="sig-name descname">random_variable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.polynomial_functional_basis.PolynomialFunctionalBasis.random_variable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the tensap.RandomVariable associated with self if it exists.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>out</strong><span class="classifier">tensap.RandomVariable or []</span></dt><dd><p>The tensap.RandomVariable associated with self if it exists, and []
otherwise.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-tensap.approximation.bases.sparse_tensor_product_functional_basis">
<span id="tensap-approximation-bases-sparse-tensor-product-functional-basis-module"></span><h2>tensap.approximation.bases.sparse_tensor_product_functional_basis module<a class="headerlink" href="#module-tensap.approximation.bases.sparse_tensor_product_functional_basis" title="Permalink to this headline">¶</a></h2>
<p>Module sparse_tensor_product_functional_basis.</p>
<dl class="py class">
<dt id="tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis">
<em class="property">class </em><code class="sig-prename descclassname">tensap.approximation.bases.sparse_tensor_product_functional_basis.</code><code class="sig-name descname">SparseTensorProductFunctionalBasis</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">bases</span></em>, <em class="sig-param"><span class="n">indices</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#tensap.approximation.bases.functional_basis.FunctionalBasis" title="tensap.approximation.bases.functional_basis.FunctionalBasis"><code class="xref py py-class docutils literal notranslate"><span class="pre">tensap.approximation.bases.functional_basis.FunctionalBasis</span></code></a></p>
<p>Class SparseTensorProductFunctionalBasis.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>bases</strong><span class="classifier">list or tensap.FunctionalBases</span></dt><dd><p>The bases associated with the object.</p>
</dd>
<dt><strong>indices</strong><span class="classifier">tensap.MultiIndices</span></dt><dd><p>The indices of the basis functions (the indices start at 0).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.adaptation_path" title="tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.adaptation_path"><code class="xref py py-obj docutils literal notranslate"><span class="pre">adaptation_path</span></code></a>([p])</p></td>
<td><p>Create an adaptation path associated with increasing p-norm of multi-indices.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.cardinal" title="tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.cardinal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cardinal</span></code></a>()</p></td>
<td><p>Return the number of basis functions.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.conditional_expectation" title="tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.conditional_expectation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">conditional_expectation</span></code></a>(dims, *args)</p></td>
<td><p>Compute the conditional expectation of self with respect to the random variables dims (a subset of range(d)).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.domain" title="tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.domain"><code class="xref py py-obj docutils literal notranslate"><span class="pre">domain</span></code></a>()</p></td>
<td><p>Return the domain of the set of basis functions, which is the support of the associated measure.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.eval" title="tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.eval"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval</span></code></a>(x)</p></td>
<td><p>Return the evaluation of the basis functions at the points x.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">expectation</span></code>()</p></td>
<td><p>Return the expectation of the basis functions.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.get_random_vector" title="tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.get_random_vector"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_random_vector</span></code></a>()</p></td>
<td><p>Return the random vector associated with the basis functions of self.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.gram_matrix" title="tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.gram_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gram_matrix</span></code></a>()</p></td>
<td><p>Return the gram matrix of the basis.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">interpolate</span></code>(y[, x])</p></td>
<td><p>Provide an interpolation on a functional basis of a function (or values of the function) y associated with a set of n interpolation points x.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">interpolation_points</span></code>(*args)</p></td>
<td><p>Return the interpolation points for the basis.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.keep_bases" title="tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.keep_bases"><code class="xref py py-obj docutils literal notranslate"><span class="pre">keep_bases</span></code></a>(ind)</p></td>
<td><p>Keep only the bases of self of index ind.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">kron</span></code>()</p></td>
<td><p>Compute the Kronecker product of two bases.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.length" title="tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.length"><code class="xref py py-obj docutils literal notranslate"><span class="pre">length</span></code></a>()</p></td>
<td><p>Return the number of bases in self.bases.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">magic_points</span></code>([x, J])</p></td>
<td><p>Provide the magic points associated with a functional basis f selected in a given set of points x.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.mean" title="tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean</span></code></a>(*args)</p></td>
<td><p>Return the mean of the basis functions.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.ndim" title="tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.ndim"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndim</span></code></a>()</p></td>
<td><p>Return the dimension n for f defined in R^n.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">orthonormalize</span></code>()</p></td>
<td><p>Orthonormalize the basis.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot</span></code>([indices, n])</p></td>
<td><p>Plot the functions of the basis.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.plot_multi_indices" title="tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.plot_multi_indices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_multi_indices</span></code></a>(*args)</p></td>
<td><p>PLot the multi-index set of the object.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">projection</span></code>(fun, G)</p></td>
<td><p>Compute the projection of the function fun onto the functional basis using the integration rule G.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">random</span></code>([n, measure])</p></td>
<td><p>Evaluate the basis using n points drawn randomly according to measure if provided, or to self.measure otherwise.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.remove_bases" title="tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.remove_bases"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_bases</span></code></a>(ind)</p></td>
<td><p>Remove bases of self of index ind.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">storage</span></code>()</p></td>
<td><p>Return the storage requirement of the FunctionalBasis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.tensor_product_interpolation" title="tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.tensor_product_interpolation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tensor_product_interpolation</span></code></a>(fun, *args)</p></td>
<td><p>Return the interpolation of function fun on a sparse grid.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.transpose" title="tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.transpose"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transpose</span></code></a>(perm)</p></td>
<td><p>Return self with the basis permutation perm.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 78%" />
<col style="width: 22%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>christoffel</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>derivative</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>eval_derivative</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>eval_with_functional_bases_evals</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>keep_mapping</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>optimal_sampling_measure</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>remove_mapping</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.adaptation_path">
<code class="sig-name descname">adaptation_path</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">p</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.adaptation_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an adaptation path associated with increasing p-norm of
multi-indices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>p</strong><span class="classifier">float, optional</span></dt><dd><p>The positive real scalar p of the p-norm. The default is 1.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>P</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>The adaptation path.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.cardinal">
<code class="sig-name descname">cardinal</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.cardinal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of basis functions.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>int</dt><dd><p>The number of basis functions.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.conditional_expectation">
<code class="sig-name descname">conditional_expectation</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dims</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.conditional_expectation" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the conditional expectation of self with respect to
the random variables dims (a subset of range(d)). The expectation
with respect to other variables (in the complementary set of
dims) is taken with respect to the probability measure given by
tensap.RandomVector XdimsC if provided, or with respect to the
probability measure associated with the corresponding bases of
the function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>The dimensions in which the expectation is computed.</p>
</dd>
<dt><strong>XdimsC: tensap.RandomVector, optional</strong></dt><dd><p>The random vector used for the computation of the conditional
expectation. The default is None, indicating to use the</p>
</dd>
<dt><strong>probability measure associated with the basis.</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>f</strong><span class="classifier">tensap.FunctionalBasisArray</span></dt><dd><p>The conditional expectation of the function.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.derivative">
<code class="sig-name descname">derivative</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.derivative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.domain">
<code class="sig-name descname">domain</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.domain" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the domain of the set of basis functions, which is the support
of the associated measure.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>The domain of the set of basis functions</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.eval">
<code class="sig-name descname">eval</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the evaluation of the basis functions at the points x.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">list or numpy.ndarray</span></dt><dd><p>The points at which the basis functions are to be evaluted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>The evaluations of the basis functions at the points x.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.eval_derivative">
<code class="sig-name descname">eval_derivative</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span></em>, <em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.eval_derivative" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.eval_with_functional_bases_evals">
<code class="sig-name descname">eval_with_functional_bases_evals</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Hx</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.eval_with_functional_bases_evals" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.get_random_vector">
<code class="sig-name descname">get_random_vector</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.get_random_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the random vector associated with the basis functions of self.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>tensap.RandomVector</dt><dd><p>The random vector associated with the basis functions of self.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.gram_matrix">
<code class="sig-name descname">gram_matrix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.gram_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the gram matrix of the basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>The gram matrix of the basis.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.keep_bases">
<code class="sig-name descname">keep_bases</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ind</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.keep_bases" title="Permalink to this definition">¶</a></dt>
<dd><p>Keep only the bases of self of index ind.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ind</strong><span class="classifier">int or list or numpy.ndarray</span></dt><dd><p>The indices of the bases to keep.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>tensap.SparseTensorProductFunctionalBasis</dt><dd><p>The SparseTensorProductFunctionalBasis with kept bases.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.keep_mapping">
<code class="sig-name descname">keep_mapping</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ind</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.keep_mapping" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.length">
<code class="sig-name descname">length</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.length" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of bases in self.bases.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>int</dt><dd><p>The number of bases in self.bases.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.mean">
<code class="sig-name descname">mean</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the mean of the basis functions.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>The mean of the basis functions.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.ndim">
<code class="sig-name descname">ndim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.ndim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dimension n for f defined in R^n.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>int</dt><dd><p>The dimension n for f defined in R^n.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.plot_multi_indices">
<code class="sig-name descname">plot_multi_indices</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.plot_multi_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>PLot the multi-index set of the object.</p>
<p>See also tensap.MultiIndices.plot.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>*args</strong><span class="classifier">tuple</span></dt><dd><p>Additional parameters for tensap.MultiIndices’ plot method.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.remove_bases">
<code class="sig-name descname">remove_bases</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ind</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.remove_bases" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove bases of self of index ind.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ind</strong><span class="classifier">int or list or numpy.ndarray</span></dt><dd><p>The indices of the bases to remove.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>tensap.SparseTensorProductFunctionalBasis</dt><dd><p>The SparseTensorProductFunctionalBasis with removed bases.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.remove_mapping">
<code class="sig-name descname">remove_mapping</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ind</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.remove_mapping" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.tensor_product_interpolation">
<code class="sig-name descname">tensor_product_interpolation</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fun</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.tensor_product_interpolation" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the interpolation of function fun on a sparse grid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fun</strong><span class="classifier">function or tensap.Function</span></dt><dd><p>The function to interpolate.</p>
</dd>
<dt><strong>grid</strong><span class="classifier">list, optional</span></dt><dd><p>The grid of points used for the interpolation. If one grid has more
points than the dimension of the corresponding basis, use
magicPoints for the selection of a subset of points adapted to the
basis. The default is None, indicating to use the method
self.bases.interpolation_points().</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>tensap.FunctionalTensor</dt><dd><p>The interpolation of the function.</p>
</dd>
<dt><strong>output</strong><span class="classifier">dict</span></dt><dd><p>A dictionnary of outputs of the method.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If the argument fun is neither a tensap.Function, a function nor
a tensap.Tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.transpose">
<code class="sig-name descname">transpose</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">perm</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.sparse_tensor_product_functional_basis.SparseTensorProductFunctionalBasis.transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self with the basis permutation perm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>perm</strong><span class="classifier">list or numpy.ndarray</span></dt><dd><p>The permutation of the bases.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>tensap.SparseTensorProductFunctionalBasis</dt><dd><p>The SparseTensorProductFunctionalBasis with permuted bases.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-tensap.approximation.bases.sub_functional_basis">
<span id="tensap-approximation-bases-sub-functional-basis-module"></span><h2>tensap.approximation.bases.sub_functional_basis module<a class="headerlink" href="#module-tensap.approximation.bases.sub_functional_basis" title="Permalink to this headline">¶</a></h2>
<p>Module sub_functional_basis.</p>
<dl class="py class">
<dt id="tensap.approximation.bases.sub_functional_basis.SubFunctionalBasis">
<em class="property">class </em><code class="sig-prename descclassname">tensap.approximation.bases.sub_functional_basis.</code><code class="sig-name descname">SubFunctionalBasis</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">underlying_basis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">basis</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.sub_functional_basis.SubFunctionalBasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#tensap.approximation.bases.functional_basis.FunctionalBasis" title="tensap.approximation.bases.functional_basis.FunctionalBasis"><code class="xref py py-class docutils literal notranslate"><span class="pre">tensap.approximation.bases.functional_basis.FunctionalBasis</span></code></a></p>
<p>Class SubFunctionalBasis.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>underlying_basis</strong><span class="classifier">tensap.FunctionalBasis</span></dt><dd><p>The underlying basis.</p>
</dd>
<dt><strong>basis</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Array of shape (n, m), where n is the number of elements in
underlying_basis, which defines a set of m basis functions in the space
generated by underlying_basis.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">adaptation_path</span></code>()</p></td>
<td><p>Return the adaptation path of the functional basis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.sub_functional_basis.SubFunctionalBasis.cardinal" title="tensap.approximation.bases.sub_functional_basis.SubFunctionalBasis.cardinal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cardinal</span></code></a>()</p></td>
<td><p>Return the number of basis functions.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">conditional_expectation</span></code>()</p></td>
<td><p>Compute the conditional expectation of self with respect to the random variables dims (a subset of range(d)).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.sub_functional_basis.SubFunctionalBasis.derivative" title="tensap.approximation.bases.sub_functional_basis.SubFunctionalBasis.derivative"><code class="xref py py-obj docutils literal notranslate"><span class="pre">derivative</span></code></a>(n)</p></td>
<td><p>Compute the k-th order derivative of the functions of the basis projected on itself.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.sub_functional_basis.SubFunctionalBasis.domain" title="tensap.approximation.bases.sub_functional_basis.SubFunctionalBasis.domain"><code class="xref py py-obj docutils literal notranslate"><span class="pre">domain</span></code></a>()</p></td>
<td><p>Return the domain of the set of basis functions, which is the support of the associated measure.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.sub_functional_basis.SubFunctionalBasis.eval" title="tensap.approximation.bases.sub_functional_basis.SubFunctionalBasis.eval"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval</span></code></a>(x[, indices])</p></td>
<td><p>Return the evaluation of the basis functions at the points x.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.sub_functional_basis.SubFunctionalBasis.eval_derivative" title="tensap.approximation.bases.sub_functional_basis.SubFunctionalBasis.eval_derivative"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval_derivative</span></code></a>(n, x)</p></td>
<td><p>Evaluate the k-th order derivative of the functions of the basis at the points x.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">expectation</span></code>()</p></td>
<td><p>Return the expectation of the basis functions.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">interpolate</span></code>(y[, x])</p></td>
<td><p>Provide an interpolation on a functional basis of a function (or values of the function) y associated with a set of n interpolation points x.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">interpolation_points</span></code>(*args)</p></td>
<td><p>Return the interpolation points for the basis.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">kron</span></code>()</p></td>
<td><p>Compute the Kronecker product of two bases.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">magic_points</span></code>([x, J])</p></td>
<td><p>Provide the magic points associated with a functional basis f selected in a given set of points x.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.sub_functional_basis.SubFunctionalBasis.mean" title="tensap.approximation.bases.sub_functional_basis.SubFunctionalBasis.mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean</span></code></a>()</p></td>
<td><p>Return the mean of the basis functions.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.sub_functional_basis.SubFunctionalBasis.ndim" title="tensap.approximation.bases.sub_functional_basis.SubFunctionalBasis.ndim"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndim</span></code></a>()</p></td>
<td><p>Return the dimension n for f defined in R^n.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.sub_functional_basis.SubFunctionalBasis.orthonormalize" title="tensap.approximation.bases.sub_functional_basis.SubFunctionalBasis.orthonormalize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">orthonormalize</span></code></a>()</p></td>
<td><p>Orthonormalize the SubFunctionalBasis.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot</span></code>([indices, n])</p></td>
<td><p>Plot the functions of the basis.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">projection</span></code>(fun, G)</p></td>
<td><p>Compute the projection of the function fun onto the functional basis using the integration rule G.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">random</span></code>([n, measure])</p></td>
<td><p>Evaluate the basis using n points drawn randomly according to measure if provided, or to self.measure otherwise.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.sub_functional_basis.SubFunctionalBasis.storage" title="tensap.approximation.bases.sub_functional_basis.SubFunctionalBasis.storage"><code class="xref py py-obj docutils literal notranslate"><span class="pre">storage</span></code></a>()</p></td>
<td><p>Return the storage requirement of the FunctionalBasis.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 74%" />
<col style="width: 26%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>christoffel</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>optimal_sampling_measure</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="tensap.approximation.bases.sub_functional_basis.SubFunctionalBasis.cardinal">
<code class="sig-name descname">cardinal</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.sub_functional_basis.SubFunctionalBasis.cardinal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of basis functions.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>int</dt><dd><p>The number of basis functions.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.sub_functional_basis.SubFunctionalBasis.derivative">
<code class="sig-name descname">derivative</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.sub_functional_basis.SubFunctionalBasis.derivative" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the k-th order derivative of the functions of the basis
projected on itself.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>k</strong><span class="classifier">int</span></dt><dd><p>The order of the derivative.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>tensap.SubFunctionalBasis</dt><dd><p>The k-th order derivative of the functions of the basis projected
on itself.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.sub_functional_basis.SubFunctionalBasis.domain">
<code class="sig-name descname">domain</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.sub_functional_basis.SubFunctionalBasis.domain" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the domain of the set of basis functions, which is the support
of the associated measure.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>The domain of the set of basis functions</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.sub_functional_basis.SubFunctionalBasis.eval">
<code class="sig-name descname">eval</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">indices</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.sub_functional_basis.SubFunctionalBasis.eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the evaluation of the basis functions at the points x.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">list or numpy.ndarray</span></dt><dd><p>The points at which the basis functions are to be evaluted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>The evaluations of the basis functions at the points x.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.sub_functional_basis.SubFunctionalBasis.eval_derivative">
<code class="sig-name descname">eval_derivative</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span></em>, <em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.sub_functional_basis.SubFunctionalBasis.eval_derivative" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the k-th order derivative of the functions of the basis at the
points x.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>k</strong><span class="classifier">int</span></dt><dd><p>The order of the derivative.</p>
</dd>
<dt><strong>x</strong><span class="classifier">list or numpy.ndarray</span></dt><dd><p>The points at which the k-th derivative of the basis functions are
to be evaluated.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>The evaluations of the k-th derivative of the functions of
self.basis of degrees in self.indices at points x.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.sub_functional_basis.SubFunctionalBasis.mean">
<code class="sig-name descname">mean</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.sub_functional_basis.SubFunctionalBasis.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the mean of the basis functions.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>The mean of the basis functions.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.sub_functional_basis.SubFunctionalBasis.ndim">
<code class="sig-name descname">ndim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.sub_functional_basis.SubFunctionalBasis.ndim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dimension n for f defined in R^n.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>int</dt><dd><p>The dimension n for f defined in R^n.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.sub_functional_basis.SubFunctionalBasis.orthonormalize">
<code class="sig-name descname">orthonormalize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.sub_functional_basis.SubFunctionalBasis.orthonormalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Orthonormalize the SubFunctionalBasis.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>tensap.SubFunctionalBasis</dt><dd><p>The orthonormalized SubFunctionalBasis.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.sub_functional_basis.SubFunctionalBasis.storage">
<code class="sig-name descname">storage</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.sub_functional_basis.SubFunctionalBasis.storage" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the storage requirement of the FunctionalBasis.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>int</dt><dd><p>The storage requirement of the FunctionalBasis.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-tensap.approximation.bases.user_defined_functional_basis">
<span id="tensap-approximation-bases-user-defined-functional-basis-module"></span><h2>tensap.approximation.bases.user_defined_functional_basis module<a class="headerlink" href="#module-tensap.approximation.bases.user_defined_functional_basis" title="Permalink to this headline">¶</a></h2>
<p>Module user_defined_functional_basis.</p>
<dl class="py class">
<dt id="tensap.approximation.bases.user_defined_functional_basis.UserDefinedFunctionalBasis">
<em class="property">class </em><code class="sig-prename descclassname">tensap.approximation.bases.user_defined_functional_basis.</code><code class="sig-name descname">UserDefinedFunctionalBasis</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">h_fun</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">measure</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">input_dim</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.user_defined_functional_basis.UserDefinedFunctionalBasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#tensap.approximation.bases.functional_basis.FunctionalBasis" title="tensap.approximation.bases.functional_basis.FunctionalBasis"><code class="xref py py-class docutils literal notranslate"><span class="pre">tensap.approximation.bases.functional_basis.FunctionalBasis</span></code></a></p>
<p>Class UserDefinedFunctionalBasis.</p>
<p>The basis is not L2-orthonormal a priori, hence the is_orthonormal
attribute remains at its default value of False.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>handle_fun</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>The functions making the basis.</p>
</dd>
<dt><strong>measure</strong><span class="classifier">tensap.Measure</span></dt><dd><p>The measure associated with the basis. Can be a tensap.RandomVector or
a tensap.RandomVariable to define a random generator and an
expectation.</p>
</dd>
<dt><strong>input_dimension</strong><span class="classifier">int</span></dt><dd><p>The dimension of the domain of the functions in handle_fun.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">adaptation_path</span></code>()</p></td>
<td><p>Return the adaptation path of the functional basis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.user_defined_functional_basis.UserDefinedFunctionalBasis.cardinal" title="tensap.approximation.bases.user_defined_functional_basis.UserDefinedFunctionalBasis.cardinal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cardinal</span></code></a>()</p></td>
<td><p>Return the number of basis functions.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">conditional_expectation</span></code>()</p></td>
<td><p>Compute the conditional expectation of self with respect to the random variables dims (a subset of range(d)).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.user_defined_functional_basis.UserDefinedFunctionalBasis.domain" title="tensap.approximation.bases.user_defined_functional_basis.UserDefinedFunctionalBasis.domain"><code class="xref py py-obj docutils literal notranslate"><span class="pre">domain</span></code></a>()</p></td>
<td><p>Return the domain of the set of basis functions, which is the support of the associated measure.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.approximation.bases.user_defined_functional_basis.UserDefinedFunctionalBasis.eval" title="tensap.approximation.bases.user_defined_functional_basis.UserDefinedFunctionalBasis.eval"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval</span></code></a>(x)</p></td>
<td><p>Return the evaluation of the basis functions at the points x.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">expectation</span></code>()</p></td>
<td><p>Return the expectation of the basis functions.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">interpolate</span></code>(y[, x])</p></td>
<td><p>Provide an interpolation on a functional basis of a function (or values of the function) y associated with a set of n interpolation points x.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">interpolation_points</span></code>(*args)</p></td>
<td><p>Return the interpolation points for the basis.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">kron</span></code>()</p></td>
<td><p>Compute the Kronecker product of two bases.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">magic_points</span></code>([x, J])</p></td>
<td><p>Provide the magic points associated with a functional basis f selected in a given set of points x.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean</span></code>()</p></td>
<td><p>Return the mean of the basis functions.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.approximation.bases.user_defined_functional_basis.UserDefinedFunctionalBasis.ndim" title="tensap.approximation.bases.user_defined_functional_basis.UserDefinedFunctionalBasis.ndim"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndim</span></code></a>()</p></td>
<td><p>Return the dimension n for f defined in R^n.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">orthonormalize</span></code>()</p></td>
<td><p>Orthonormalize the basis.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot</span></code>([indices, n])</p></td>
<td><p>Plot the functions of the basis.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">projection</span></code>(fun, G)</p></td>
<td><p>Compute the projection of the function fun onto the functional basis using the integration rule G.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">random</span></code>([n, measure])</p></td>
<td><p>Evaluate the basis using n points drawn randomly according to measure if provided, or to self.measure otherwise.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">storage</span></code>()</p></td>
<td><p>Return the storage requirement of the FunctionalBasis.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 74%" />
<col style="width: 26%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>christoffel</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>optimal_sampling_measure</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="tensap.approximation.bases.user_defined_functional_basis.UserDefinedFunctionalBasis.cardinal">
<code class="sig-name descname">cardinal</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.user_defined_functional_basis.UserDefinedFunctionalBasis.cardinal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of basis functions.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>int</dt><dd><p>The number of basis functions.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.user_defined_functional_basis.UserDefinedFunctionalBasis.domain">
<code class="sig-name descname">domain</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.user_defined_functional_basis.UserDefinedFunctionalBasis.domain" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the domain of the set of basis functions, which is the support
of the associated measure.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>The domain of the set of basis functions</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.user_defined_functional_basis.UserDefinedFunctionalBasis.eval">
<code class="sig-name descname">eval</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.user_defined_functional_basis.UserDefinedFunctionalBasis.eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the evaluation of the basis functions at the points x.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">list or numpy.ndarray</span></dt><dd><p>The points at which the basis functions are to be evaluted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>The evaluations of the basis functions at the points x.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.approximation.bases.user_defined_functional_basis.UserDefinedFunctionalBasis.ndim">
<code class="sig-name descname">ndim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.approximation.bases.user_defined_functional_basis.UserDefinedFunctionalBasis.ndim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dimension n for f defined in R^n.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>int</dt><dd><p>The dimension n for f defined in R^n.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-tensap.approximation.bases">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-tensap.approximation.bases" title="Permalink to this headline">¶</a></h2>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">tensap</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="tensap.approximation.html">tensap.approximation package</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="tensap.approximation.html#subpackages">Subpackages</a></li>
<li class="toctree-l2"><a class="reference internal" href="tensap.approximation.html#module-tensap.approximation">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="tensap.functions.html">tensap.functions package</a></li>
<li class="toctree-l1"><a class="reference internal" href="tensap.linear_algebra.html">tensap.linear_algebra package</a></li>
<li class="toctree-l1"><a class="reference internal" href="tensap.tensor_algebra.html">tensap.tensor_algebra package</a></li>
<li class="toctree-l1"><a class="reference internal" href="tensap.tools.html">tensap.tools package</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  <li><a href="tensap.approximation.html">tensap.approximation package</a><ul>
      <li>Previous: <a href="tensap.approximation.html" title="previous chapter">tensap.approximation package</a></li>
      <li>Next: <a href="tensap.approximation.integration.html" title="next chapter">tensap.approximation.integration package</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, A. Nouy, E. Grelier.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/tensap.approximation.bases.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>