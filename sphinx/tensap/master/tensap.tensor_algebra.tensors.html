
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>tensap.tensor_algebra.tensors package &#8212; tensap 1.1 documentation</title>
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="tensap.tensor_algebra.tools package" href="tensap.tensor_algebra.tools.html" />
    <link rel="prev" title="tensap.tensor_algebra package" href="tensap.tensor_algebra.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="tensap-tensor-algebra-tensors-package">
<h1>tensap.tensor_algebra.tensors package<a class="headerlink" href="#tensap-tensor-algebra-tensors-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-tensap.tensor_algebra.tensors.canonical_tensor">
<span id="tensap-tensor-algebra-tensors-canonical-tensor-module"></span><h2>tensap.tensor_algebra.tensors.canonical_tensor module<a class="headerlink" href="#module-tensap.tensor_algebra.tensors.canonical_tensor" title="Permalink to this headline">¶</a></h2>
<p>Module canonical_tensor.</p>
<dl class="py class">
<dt id="tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">tensap.tensor_algebra.tensors.canonical_tensor.</span></code><code class="sig-name descname"><span class="pre">CanonicalTensor</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">space</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">core</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Class CanonicalTensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>core</strong><span class="classifier">tensap.DiagonalTensor</span></dt><dd><p>The core of the canonical tensor.</p>
</dd>
<dt><strong>space</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>The tensor space.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int</span></dt><dd><p>The order of the tensor.</p>
</dd>
<dt><strong>shape</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>The shape of the tensor.</p>
</dd>
<dt><strong>is_orth</strong><span class="classifier">bool</span></dt><dd><p>Boolean indicating, if is_orth = True, the dimension mu for which
the mu-matricization of the tensor is orthogonal.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.create" title="tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.create"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create</span></code></a>(generator, rank, shape)</p></td>
<td><p>Create a FullTensor of rank rank and shape shape using a given generator.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.dot" title="tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.dot"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dot</span></code></a>(tensor_2)</p></td>
<td><p>Return the inner product of two tensors.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.eval_diag" title="tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.eval_diag"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval_diag</span></code></a>([dims])</p></td>
<td><p>Extract the diagonal of the tensor.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.full" title="tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.full"><code class="xref py py-obj docutils literal notranslate"><span class="pre">full</span></code></a>()</p></td>
<td><p>Convert the object to a tensap.FullTensor.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.norm" title="tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.norm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">norm</span></code></a>([matrix])</p></td>
<td><p>Compute the canonical norm of the CanonicalTensor.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.numpy" title="tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.numpy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span></code></a>()</p></td>
<td><p>Convert the CanonicalTensor to a numpy.ndarray.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.ones" title="tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.ones"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ones</span></code></a>(rank, shape)</p></td>
<td><p>Create a FullTensor of rank rank and shape shape with entries equal to 1.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.orth" title="tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.orth"><code class="xref py py-obj docutils literal notranslate"><span class="pre">orth</span></code></a>()</p></td>
<td><p>Return an orthonormalized representation of the tensor.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.parameter_gradient_eval_diag" title="tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.parameter_gradient_eval_diag"><code class="xref py py-obj docutils literal notranslate"><span class="pre">parameter_gradient_eval_diag</span></code></a>(mu[, matrices])</p></td>
<td><p>Compute the diagonal of the gradient of the tensor with respect to a given parameter.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.rand" title="tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.rand"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rand</span></code></a>(rank, shape)</p></td>
<td><p>Create a FullTensor of rank rank and shape shape with i.i.d.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.randn" title="tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.randn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">randn</span></code></a>(rank, shape)</p></td>
<td><p>Create a FullTensor of rank rank and shape shape with i.i.d.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.representation_rank" title="tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.representation_rank"><code class="xref py py-obj docutils literal notranslate"><span class="pre">representation_rank</span></code></a>()</p></td>
<td><p>Return the representation rank of the tensor.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.sparse_storage" title="tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.sparse_storage"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sparse_storage</span></code></a>()</p></td>
<td><p>Return the sparse storage complexity of the CanonicalTensor.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.storage" title="tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.storage"><code class="xref py py-obj docutils literal notranslate"><span class="pre">storage</span></code></a>()</p></td>
<td><p>Return the storage complexity of the CanonicalTensor.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.tensor_matrix_product" title="tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.tensor_matrix_product"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tensor_matrix_product</span></code></a>(matrices[, dims])</p></td>
<td><p>Contract a tensor with matrices.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.tensor_matrix_product_eval_diag" title="tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.tensor_matrix_product_eval_diag"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tensor_matrix_product_eval_diag</span></code></a>(matrices[, dims])</p></td>
<td><p>Evaluate the diagonal of a tensor obtained by contraction with matrices.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.tree_based_tensor" title="tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.tree_based_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tree_based_tensor</span></code></a>(tree[, is_active_node])</p></td>
<td><p>Convert a CanonicalTensor to a tensap.TreeBasedTensor with given dimension tree and active nodes.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.zeros" title="tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.zeros"><code class="xref py py-obj docutils literal notranslate"><span class="pre">zeros</span></code></a>(rank, shape)</p></td>
<td><p>Create a FullTensor of rank rank and shape shape with entries equal to 0.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.create">
<em class="property"><span class="pre">static</span> </em><code class="sig-name descname"><span class="pre">create</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">generator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rank</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a FullTensor of rank rank and shape shape using a given
generator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>generator</strong><span class="classifier">function</span></dt><dd><p>Function generating a numpy.ndarray, given a shape.</p>
</dd>
<dt><strong>rank</strong><span class="classifier">int</span></dt><dd><p>The rank of the tensor.</p>
</dd>
<dt><strong>shape</strong><span class="classifier">numpy.ndarray or list</span></dt><dd><p>The shape of the tensor.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>CanonicalTensor</dt><dd><p>The created tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.dot">
<code class="sig-name descname"><span class="pre">dot</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensor_2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the inner product of two tensors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tensor2</strong><span class="classifier">CanonicalTensor</span></dt><dd><p>The second tensor of the inner products.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.float</dt><dd><p>The inner product of the two tensors.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.eval_diag">
<code class="sig-name descname"><span class="pre">eval_diag</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.eval_diag" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract the diagonal of the tensor.</p>
<p>The tensor must be such that self.shape[mu] = n for all mu (in dims if
provided).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list of numpy.ndarray, optional</span></dt><dd><p>The dimensions associated with the indices of the diagonal. The
default is None,indicating that the indices refer to all the
dimensions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>data</strong><span class="classifier">CanonicalTensor or tensap.FullTensor</span></dt><dd><p>The evaluations of the diagonal of the tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.full">
<code class="sig-name descname"><span class="pre">full</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.full" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the object to a tensap.FullTensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>tensap.FullTensor</dt><dd><p>The canonical tensor as a tensap.FullTensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.ndim">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">ndim</span></code><a class="headerlink" href="#tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.ndim" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the order of the tensor. Equivalent to self.order.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>int</dt><dd><p>The order of the tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.norm">
<code class="sig-name descname"><span class="pre">norm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the canonical norm of the CanonicalTensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>numpy.float</dt><dd><p>The norm of the tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.numpy">
<code class="sig-name descname"><span class="pre">numpy</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.numpy" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the CanonicalTensor to a numpy.ndarray.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>The CanonicalTensor as a numpy.ndarray.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.ones">
<em class="property"><span class="pre">static</span> </em><code class="sig-name descname"><span class="pre">ones</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rank</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.ones" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a FullTensor of rank rank and shape shape with entries equal to
1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rank</strong><span class="classifier">int</span></dt><dd><p>The rank of the tensor.</p>
</dd>
<dt><strong>shape</strong><span class="classifier">numpy.ndarray or list</span></dt><dd><p>The shape of the tensor.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>CanonicalTensor</dt><dd><p>The created tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.orth">
<code class="sig-name descname"><span class="pre">orth</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.orth" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an orthonormalized representation of the tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>out</strong><span class="classifier">CanonicalTensor</span></dt><dd><p>The orthonormalized representation of the tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.parameter_gradient_eval_diag">
<code class="sig-name descname"><span class="pre">parameter_gradient_eval_diag</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">matrices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.parameter_gradient_eval_diag" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the diagonal of the gradient of the tensor with respect to a
given parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mu</strong><span class="classifier">int</span></dt><dd><p>Index of the parameter.</p>
</dd>
<dt><strong>matrices</strong><span class="classifier">list or numpy.array, optional</span></dt><dd><p>Matrices with which to compute outer_product_eval_diag if alpha is
associated with some dimensions. Useful for evaluation the gradient
of a tensap.FunctionalTensor. The default is None, indicating
identity matrices.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">tensap.FullTensor</span></dt><dd><p>The diagonal of the gradient of the tensor with respect to
the parameter with index mu.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.rand">
<em class="property"><span class="pre">static</span> </em><code class="sig-name descname"><span class="pre">rand</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rank</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.rand" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a FullTensor of rank rank and shape shape with i.i.d. entries
drawn according to the uniform distribution on [0, 1].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rank</strong><span class="classifier">int</span></dt><dd><p>The rank of the tensor.</p>
</dd>
<dt><strong>shape</strong><span class="classifier">numpy.ndarray or list</span></dt><dd><p>The shape of the tensor.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>CanonicalTensor</dt><dd><p>The created tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.randn">
<em class="property"><span class="pre">static</span> </em><code class="sig-name descname"><span class="pre">randn</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rank</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.randn" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a FullTensor of rank rank and shape shape with i.i.d. entries
drawn according to the standard gaussian distribution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rank</strong><span class="classifier">int</span></dt><dd><p>The rank of the tensor.</p>
</dd>
<dt><strong>shape</strong><span class="classifier">numpy.ndarray or list</span></dt><dd><p>The shape of the tensor.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>CanonicalTensor</dt><dd><p>The created tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.representation_rank">
<code class="sig-name descname"><span class="pre">representation_rank</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.representation_rank" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the representation rank of the tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>int</dt><dd><p>The representation rank of the tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.sparse_storage">
<code class="sig-name descname"><span class="pre">sparse_storage</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.sparse_storage" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sparse storage complexity of the CanonicalTensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>int</dt><dd><p>The sparse storage complexity of the CanonicalTensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.storage">
<code class="sig-name descname"><span class="pre">storage</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.storage" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the storage complexity of the CanonicalTensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>int</dt><dd><p>The storage complexity of the CanonicalTensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.tensor_matrix_product">
<code class="sig-name descname"><span class="pre">tensor_matrix_product</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.tensor_matrix_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Contract a tensor with matrices.</p>
<p>The second dimension of the matrix matrices[k] is contracted with the
k-th dimension of self, with the indices k given in dims (if provided).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>matrices</strong><span class="classifier">numpy.ndarray or list of numpy.ndarray</span></dt><dd><p>The matrices to use in the product.</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list or numpy.ndarray, optional</span></dt><dd><p>Indices of the contractions. The default is None, indicating all
the dimensions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>CanonicalTensor</dt><dd><p>The tensor after the contractions with the matrices.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.tensor_matrix_product_eval_diag">
<code class="sig-name descname"><span class="pre">tensor_matrix_product_eval_diag</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.tensor_matrix_product_eval_diag" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the diagonal of a tensor obtained by contraction with
matrices.</p>
<p>Provides the diagonal of the tensor obtained by contracting the tensor
with matrices H[k] along dimensions dims(k)+1, for k = 0, …,
dims.size-1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>matrices</strong><span class="classifier">list</span></dt><dd><p>The matrices to use in the product.</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list or numpy.ndarray, optional</span></dt><dd><p>Indices of the contractions. The default is None, indicating all
the dimensions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">CanonicalTensor or tensap.FullTensor</span></dt><dd><p>The diagonal of the contractions of the tensor with the matrices.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.tree_based_tensor">
<code class="sig-name descname"><span class="pre">tree_based_tensor</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tree</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_active_node</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.tree_based_tensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a CanonicalTensor to a tensap.TreeBasedTensor with given
dimension tree and active nodes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tree</strong><span class="classifier">tensap.DimensionTree</span></dt><dd><p>The dimension tree.</p>
</dd>
<dt><strong>is_active_node</strong><span class="classifier">list or numpy.ndarray, optional</span></dt><dd><p>Booleans indicating if the nodes are active. The default is None,
settings all the nodes active.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">tensap.TreeBasedTensor</span></dt><dd><p>The canonical tensor converted into a tree-based tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.zeros">
<em class="property"><span class="pre">static</span> </em><code class="sig-name descname"><span class="pre">zeros</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rank</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.canonical_tensor.CanonicalTensor.zeros" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a FullTensor of rank rank and shape shape with entries equal to
0.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rank</strong><span class="classifier">int</span></dt><dd><p>The rank of the tensor.</p>
</dd>
<dt><strong>shape</strong><span class="classifier">numpy.ndarray or list</span></dt><dd><p>The shape of the tensor.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>CanonicalTensor</dt><dd><p>The created tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-tensap.tensor_algebra.tensors.diagonal_tensor">
<span id="tensap-tensor-algebra-tensors-diagonal-tensor-module"></span><h2>tensap.tensor_algebra.tensors.diagonal_tensor module<a class="headerlink" href="#module-tensap.tensor_algebra.tensors.diagonal_tensor" title="Permalink to this headline">¶</a></h2>
<p>Module diagonal_tensor.</p>
<dl class="py class">
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">tensap.tensor_algebra.tensors.diagonal_tensor.</span></code><code class="sig-name descname"><span class="pre">DiagonalTensor</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Class DiagonalTensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>The diagonal entries of the tensor.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int</span></dt><dd><p>The order of the tensor.</p>
</dd>
<dt><strong>shape</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>The shape of the tensor.</p>
</dd>
<dt><strong>is_orth</strong><span class="classifier">bool</span></dt><dd><p>Boolean indicating if the representation of the tensor is orthogonal
(i.e. one mu-matricization is orthogonal).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.cat" title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.cat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cat</span></code></a>(y)</p></td>
<td><p>Concatenate the tensors.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.create" title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.create"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create</span></code></a>(generator, rank, order)</p></td>
<td><p>Create a DiagonalTensor of rank rank and order order using a given generator.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.dot" title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.dot"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dot</span></code></a>(y)</p></td>
<td><p>Return the inner product of two tensors.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.dot_with_rank_one_metric" title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.dot_with_rank_one_metric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dot_with_rank_one_metric</span></code></a>(y, matrix)</p></td>
<td><p>Compute the weighted inner product of two tensors.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.eval_at_indices" title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.eval_at_indices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval_at_indices</span></code></a>(ind[, dims])</p></td>
<td><p>Evaluate the tensor at indices.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.eval_diag" title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.eval_diag"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval_diag</span></code></a>([dims])</p></td>
<td><p>Extract the diagonal of the tensor.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.full" title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.full"><code class="xref py py-obj docutils literal notranslate"><span class="pre">full</span></code></a>()</p></td>
<td><p>Convert the DiagonalTensor to a tensap.FullTensor.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.itranspose" title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.itranspose"><code class="xref py py-obj docutils literal notranslate"><span class="pre">itranspose</span></code></a>(dims)</p></td>
<td><p>Return the inverse transpose (permutation) of the dimensions of the tensor.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.kron" title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.kron"><code class="xref py py-obj docutils literal notranslate"><span class="pre">kron</span></code></a>(y)</p></td>
<td><p>Kronecker product of tensors.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.norm" title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.norm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">norm</span></code></a>()</p></td>
<td><p>Compute the canonical norm of the DiagonalTensor.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.numpy" title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.numpy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span></code></a>()</p></td>
<td><p>Convert the DiagonalTensor to a numpy.ndarray.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.ones" title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.ones"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ones</span></code></a>(rank, order)</p></td>
<td><p>Create a DiagonalTensor of rank rank and order order with with entries equal to 1.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.orth" title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.orth"><code class="xref py py-obj docutils literal notranslate"><span class="pre">orth</span></code></a>()</p></td>
<td><p>Placeholder method returning a copy of self.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.rand" title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.rand"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rand</span></code></a>(rank, order)</p></td>
<td><p>Create a DiagonalTensor of rank rank and order order with i.i.d.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.randn" title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.randn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">randn</span></code></a>(rank, order)</p></td>
<td><p>Create a DiagonalTensor of rank rank and order order with i.i.d.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.reshape" title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.reshape"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reshape</span></code></a>(shape)</p></td>
<td><p>Reshape the tensor.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.sparse" title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.sparse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sparse</span></code></a>()</p></td>
<td><p>Convert the DiagonalTensor to a tensap.SparseTensor.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.sparse_storage" title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.sparse_storage"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sparse_storage</span></code></a>()</p></td>
<td><p>Return the sparse storage complexity of the DiagonalTensor.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.storage" title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.storage"><code class="xref py py-obj docutils literal notranslate"><span class="pre">storage</span></code></a>()</p></td>
<td><p>Return the storage complexity of the DiagonalTensor.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.sub_tensor" title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.sub_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sub_tensor</span></code></a>(*args)</p></td>
<td><p>Extract a subtensor of the tensor.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.tensor_diagonal_matrix_product" title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.tensor_diagonal_matrix_product"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tensor_diagonal_matrix_product</span></code></a>(matrices)</p></td>
<td><p>Contract a FullTensor with matrices built from their diagonals.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.tensor_matrix_product" title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.tensor_matrix_product"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tensor_matrix_product</span></code></a>(matrices[, dims])</p></td>
<td><p>Contract a tensor with matrices.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.tensor_matrix_product_eval_diag" title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.tensor_matrix_product_eval_diag"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tensor_matrix_product_eval_diag</span></code></a>(matrices[, dims])</p></td>
<td><p>Evaluate the diagonal of a tensor obtained by contraction with matrices.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.tensor_vector_product" title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.tensor_vector_product"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tensor_vector_product</span></code></a>(vectors)</p></td>
<td><p>Compute the contraction of the tensor with vectors.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.tensordot" title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.tensordot"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tensordot</span></code></a>(y, dims1[, dims2])</p></td>
<td><p>Contract two tensors along specified dimensions.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.tensordot_matrix_product_except_dim" title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.tensordot_matrix_product_except_dim"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tensordot_matrix_product_except_dim</span></code></a>(y, …)</p></td>
<td><p>Particular type of contraction.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.transpose" title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.transpose"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transpose</span></code></a>(dims)</p></td>
<td><p>Transpose (permute) the dimensions of the tensor.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.tree_based_tensor" title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.tree_based_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tree_based_tensor</span></code></a>([tree, is_active_node])</p></td>
<td><p>Convert the tensap.DiagonalTensor into a tensap.TreeBasedTensor.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.update_attributes" title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.update_attributes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">update_attributes</span></code></a>()</p></td>
<td><p>Update the attribute shape of self if data or order have been modified.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.zeros" title="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.zeros"><code class="xref py py-obj docutils literal notranslate"><span class="pre">zeros</span></code></a>(rank, order)</p></td>
<td><p>Create a DiagonalTensor of rank rank and order order with with entries equal to 0.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.cat">
<code class="sig-name descname"><span class="pre">cat</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.cat" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenate the tensors.</p>
<p>Concatenates self and y in a tensor z such that:
z(i_1 ,…, i_d) = x(i_1, …, i_d) if i_k &lt;= sz[k]-1 for k in dims,
z(i_1, …, i_d) = y(i_1-sz[0], …, i_d-sz[d-1]) if i_k &gt;= sz[k]
for k in dims,
z(i_1, …, i_d) = 0 otherwise, with sz = self.shape and
dims = range(self.order).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>y</strong><span class="classifier">DiagonalTensor</span></dt><dd><p>The second tensor to be concatenaed.</p>
</dd>
<dt><strong>Returns</strong></dt><dd></dd>
<dt><strong>——-</strong></dt><dd></dd>
<dt><strong>DiagonalTensor</strong></dt><dd><p>The concatenated tensors.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.create">
<em class="property"><span class="pre">static</span> </em><code class="sig-name descname"><span class="pre">create</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">generator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rank</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a DiagonalTensor of rank rank and order order using a given
generator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>generator</strong><span class="classifier">function</span></dt><dd><p>Function generating an array, given a rank.</p>
</dd>
<dt><strong>rank</strong><span class="classifier">int</span></dt><dd><p>The rank of the tensor.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int</span></dt><dd><p>The order of the tensor.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DiagonalTensor</dt><dd><p>The created tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.dot">
<code class="sig-name descname"><span class="pre">dot</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the inner product of two tensors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tensor2</strong><span class="classifier">DiagonalTensor</span></dt><dd><p>The second tensor of the inner products.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.float</dt><dd><p>The inner product of the two tensors.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.dot_with_rank_one_metric">
<code class="sig-name descname"><span class="pre">dot_with_rank_one_metric</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">matrix</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.dot_with_rank_one_metric" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the weighted inner product of two tensors.</p>
<p>Compute the weighted canonical inner product of self and y,
where the inner product related to dimension k is weighted by
matrix[k]. It is equivalent to
self.dot(y.tensor_matrix_product(matrix)), but can be much faster.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>y</strong><span class="classifier">DiagonalTensor</span></dt><dd><p>The second tensor of the inner product.</p>
</dd>
<dt><strong>matrix</strong><span class="classifier">list or numpy.ndarray or FullTensor</span></dt><dd><p>The weight matrix.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.float</dt><dd><p>The weighted inner product.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.eval_at_indices">
<code class="sig-name descname"><span class="pre">eval_at_indices</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ind</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.eval_at_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the tensor at indices.</p>
<p>If dims is None, return
s(k) = x(indices(k, 1), indices(k, 2), …, indices(k, d)),
1 &lt;= k &lt;= self.shape[0].</p>
<p>If dims is not None, return a partial evaluation: up to a permutation
(placing the dimensions dims on the left), return
s(k, i_1, …, i_d’) = x(indices(k, 1), indices(k, 2), …,
indices(k, M), i_1, …, i_d’),
1 &lt;= k &lt;= self.shape[0], with M = dims.size and d’ = self.order - M.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>indices</strong><span class="classifier">list of numpy.ndarray</span></dt><dd><p>The indices of the tensor.</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list of numpy.ndarray, optional</span></dt><dd><p>The dimensions associated with the indices. The default is None,
indicating that indices refers to all the dimensions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>evaluations</strong><span class="classifier">numpy.ndarray or DiagonalTensor</span></dt><dd><p>The evaluations of the tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.eval_diag">
<code class="sig-name descname"><span class="pre">eval_diag</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.eval_diag" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract the diagonal of the tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list of numpy.ndarray, optional</span></dt><dd><p>The dimensions associated with the indices of the diagonal. The
default is None,indicating that the indices refer to all the
dimensions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>data</strong><span class="classifier">DiagonalTensor or numpy.ndarray</span></dt><dd><p>The evaluations of the diagonal of the tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.full">
<code class="sig-name descname"><span class="pre">full</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.full" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the DiagonalTensor to a tensap.FullTensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>tensap.FullTensor</dt><dd><p>The DiagonalTensor as a tensap.FullTensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.itranspose">
<code class="sig-name descname"><span class="pre">itranspose</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.itranspose" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the inverse transpose (permutation) of the dimensions of the
tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list or numpy.ndarray</span></dt><dd><p>The original transpose (permutation) indices.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DiagonalTensor</dt><dd><p>The transposed (permuted) tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.kron">
<code class="sig-name descname"><span class="pre">kron</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.kron" title="Permalink to this definition">¶</a></dt>
<dd><p>Kronecker product of tensors.</p>
<p>Similar to numpy.kron but for arbitrary tensors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tensor2</strong><span class="classifier">DiagonalTensor</span></dt><dd><p>The second tensor of the Kronecker product.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DiagonalTensor</dt><dd><p>The tensor resulting from the Kronecker product.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.ndim">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">ndim</span></code><a class="headerlink" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.ndim" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the order of the tensor. Equivalent to self.order.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>int</dt><dd><p>The order of the tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.norm">
<code class="sig-name descname"><span class="pre">norm</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the canonical norm of the DiagonalTensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>numpy.float</dt><dd><p>The norm of the tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.numpy">
<code class="sig-name descname"><span class="pre">numpy</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.numpy" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the DiagonalTensor to a numpy.ndarray.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>The DiagonalTensor as a numpy.ndarray.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.ones">
<em class="property"><span class="pre">static</span> </em><code class="sig-name descname"><span class="pre">ones</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rank</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.ones" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a DiagonalTensor of rank rank and order order with with
entries equal to 1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rank</strong><span class="classifier">int</span></dt><dd><p>The rank of the tensor.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int</span></dt><dd><p>The order of the tensor.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DiagonalTensor</dt><dd><p>The created tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.orth">
<code class="sig-name descname"><span class="pre">orth</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.orth" title="Permalink to this definition">¶</a></dt>
<dd><p>Placeholder method returning a copy of self.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>DiagonalTensor</dt><dd><p>A copy of self.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.rand">
<em class="property"><span class="pre">static</span> </em><code class="sig-name descname"><span class="pre">rand</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rank</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.rand" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a DiagonalTensor of rank rank and order order with i.i.d.
entries drawn according to the uniform distribution on [0, 1].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rank</strong><span class="classifier">int</span></dt><dd><p>The rank of the tensor.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int</span></dt><dd><p>The order of the tensor.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DiagonalTensor</dt><dd><p>The created tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.randn">
<em class="property"><span class="pre">static</span> </em><code class="sig-name descname"><span class="pre">randn</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rank</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.randn" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a DiagonalTensor of rank rank and order order with i.i.d.
entries drawn according to the standard gaussian distribution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rank</strong><span class="classifier">int</span></dt><dd><p>The rank of the tensor.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int</span></dt><dd><p>The order of the tensor.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DiagonalTensor</dt><dd><p>The created tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.reshape">
<code class="sig-name descname"><span class="pre">reshape</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.reshape" title="Permalink to this definition">¶</a></dt>
<dd><p>Reshape the tensor. The method has no effet.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>shape</strong><span class="classifier">list or numpy.ndarray</span></dt><dd><p>The new shape of the tensor.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>tensor</strong><span class="classifier">DiagonalTensor</span></dt><dd><p>The reshaped tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.sparse">
<code class="sig-name descname"><span class="pre">sparse</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the DiagonalTensor to a tensap.SparseTensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>tensap.SparseTensor</dt><dd><p>The DiagonalTensor as a tensap.SparseTensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.sparse_storage">
<code class="sig-name descname"><span class="pre">sparse_storage</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.sparse_storage" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sparse storage complexity of the DiagonalTensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>int</dt><dd><p>The sparse storage complexity of the DiagonalTensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.storage">
<code class="sig-name descname"><span class="pre">storage</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.storage" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the storage complexity of the DiagonalTensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>int</dt><dd><p>The storage complexity of the DiagonalTensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.sub_tensor">
<code class="sig-name descname"><span class="pre">sub_tensor</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.sub_tensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract a subtensor of the tensor.</p>
<p>See also tensap.FullTensor.sub_tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>*indices</strong><span class="classifier">list</span></dt><dd><p>The indices to extract in each dimension. ‘:’ indicates all the
indices.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>FullTensor</dt><dd><p>The subtensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.tensor_diagonal_matrix_product">
<code class="sig-name descname"><span class="pre">tensor_diagonal_matrix_product</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrices</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.tensor_diagonal_matrix_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Contract a FullTensor with matrices built from their diagonals.</p>
<p>The second dimension of the matrix matrices[k] is contracted with the
k-th dimension of self.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>matrices</strong><span class="classifier">numpy.ndarray or list of numpy.ndarray</span></dt><dd><p>The diagonals of the matrices to use in the product.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DiagonalTensor</dt><dd><p>The tensor after the contractions with the matrices.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.tensor_matrix_product">
<code class="sig-name descname"><span class="pre">tensor_matrix_product</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.tensor_matrix_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Contract a tensor with matrices.</p>
<p>The second dimension of the matrix matrices[k] is contracted with the
k-th dimension of self, with the indices k given in dims (if provided).</p>
<p>See also tensap.FullTensor.tensor_matrix_product.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>matrices</strong><span class="classifier">numpy.ndarray or list of numpy.ndarray</span></dt><dd><p>The matrices to use in the product.</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list or numpy.ndarray, optional</span></dt><dd><p>Indices of the contractions. The default is None, indicating all
the dimensions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>FullTensor</dt><dd><p>The tensor after the contractions with the matrices.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.tensor_matrix_product_eval_diag">
<code class="sig-name descname"><span class="pre">tensor_matrix_product_eval_diag</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.tensor_matrix_product_eval_diag" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the diagonal of a tensor obtained by contraction with
matrices.</p>
<p>Provides the diagonal of the tensor obtained by contracting the tensor
with matrices H[k] along dimensions dims(k)+1, for k = 0, …,
dims.size-1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>matrices</strong><span class="classifier">list</span></dt><dd><p>The matrices to use in the product.</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list or numpy.ndarray, optional</span></dt><dd><p>Indices of the contractions. The default is None, indicating all
the dimensions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>tensap.DiagonalTensor or numpy.ndarray</dt><dd><p>The diagonal of the contractions of the tensor with the matrices.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.tensor_vector_product">
<code class="sig-name descname"><span class="pre">tensor_vector_product</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vectors</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.tensor_vector_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the contraction of the tensor with vectors.</p>
<p>Compute the contraction of self with each vector contained in the list
vectors along all the dimensions. The operation is such that V[k] is
contracted with the k-th dimension of self.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vectors</strong><span class="classifier">numpy.ndarray or list of numpy.ndarray</span></dt><dd><p>The vectors to use in the product.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DiagonalTensor</dt><dd><p>The tensor after the contractions with the vectors.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.tensordot">
<code class="sig-name descname"><span class="pre">tensordot</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.tensordot" title="Permalink to this definition">¶</a></dt>
<dd><p>Contract two tensors along specified dimensions.</p>
<p>See also tensap.FullTensor.tensordot.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tensor2</strong><span class="classifier">Tensor</span></dt><dd><p>The second tensor of the contraction.</p>
</dd>
<dt><strong>dims1</strong><span class="classifier">list or int</span></dt><dd><p>The dimensions of contractions for the first tensor.</p>
</dd>
<dt><strong>dims2</strong><span class="classifier">list or int, optional</span></dt><dd><p>The dimensions of contractions for the second tensor. The default
is None which indicates, if dims1 = 0, to perform the outer
product of the two tensors, similarly to tensorflow.tensordot.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">FullTensor</span></dt><dd><p>The resulting tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.tensordot_matrix_product_except_dim">
<code class="sig-name descname"><span class="pre">tensordot_matrix_product_except_dim</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">matrices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.tensordot_matrix_product_except_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Particular type of contraction.</p>
<p>Compute a special contraction of two tensors self, y, a list of
matrices matrices and a particular dimension dim. Note that dim must
be a scalar, while matrices must be a list array with self.order
elements.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>y</strong><span class="classifier">DiagonalTensor</span></dt><dd><p>The second tensor of the contraction.</p>
</dd>
<dt><strong>matrices</strong><span class="classifier">list</span></dt><dd><p>The list of matrices of the contraction.</p>
</dd>
<dt><strong>dim</strong><span class="classifier">int</span></dt><dd><p>The excluded dimension.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>The result of the contraction.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.transpose">
<code class="sig-name descname"><span class="pre">transpose</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>Transpose (permute) the dimensions of the tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list or numpy.ndarray</span></dt><dd><p>The new ordering of the dimensions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>tensor</strong><span class="classifier">DiagonalTensor</span></dt><dd><p>The transposed (permuted) tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.tree_based_tensor">
<code class="sig-name descname"><span class="pre">tree_based_tensor</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tree</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_active_node</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.tree_based_tensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the tensap.DiagonalTensor into a tensap.TreeBasedTensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tree</strong><span class="classifier">tensap.DimensionTree, optional</span></dt><dd><p>The tree associated with the tree-based tensor representation. The
default is a linear tree.</p>
</dd>
<dt><strong>is_active_node</strong><span class="classifier">list or numpy.ndarray, optional</span></dt><dd><p>List or array of booleans indicating if each node of the tree is
active. The default is True for all nodes except the leaves.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>tensap.TreeBasedTensor</dt><dd><p>A tree-based tensor representation of the diagonal tensor.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If the internal nodes are not all active.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.update_attributes">
<code class="sig-name descname"><span class="pre">update_attributes</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.update_attributes" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the attribute shape of self if data or order have been modified.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.zeros">
<em class="property"><span class="pre">static</span> </em><code class="sig-name descname"><span class="pre">zeros</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rank</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.diagonal_tensor.DiagonalTensor.zeros" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a DiagonalTensor of rank rank and order order with with entries
equal to 0.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rank</strong><span class="classifier">int</span></dt><dd><p>The rank of the tensor.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int</span></dt><dd><p>The order of the tensor.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DiagonalTensor</dt><dd><p>The created tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-tensap.tensor_algebra.tensors.dimension_tree">
<span id="tensap-tensor-algebra-tensors-dimension-tree-module"></span><h2>tensap.tensor_algebra.tensors.dimension_tree module<a class="headerlink" href="#module-tensap.tensor_algebra.tensors.dimension_tree" title="Permalink to this headline">¶</a></h2>
<p>Module dimension_tree.</p>
<dl class="py class">
<dt id="tensap.tensor_algebra.tensors.dimension_tree.DimensionTree">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">tensap.tensor_algebra.tensors.dimension_tree.</span></code><code class="sig-name descname"><span class="pre">DimensionTree</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim2ind</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">adjacency_matrix</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.dimension_tree.DimensionTree" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Class DimensionTree.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>adjacency_matrix</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Adjacency matrix. The nth row indicates the sons of the (n+1)th node.
The nth column indicates the parents of the (n+1)th node.</p>
</dd>
<dt><strong>arity</strong><span class="classifier">int</span></dt><dd><p>Maximal number of children.</p>
</dd>
<dt><strong>_child_number</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>_child_number[n] = k means that (n+1)th node is the kth child of its
parent.</p>
</dd>
<dt><strong>_children</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>_children[:,n] is the set of indices of the children of (n+1)th node.</p>
</dd>
<dt><strong>dim2ind</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>dim2ind[k] is the index of the node (leaf) corresponding to
dimension k.</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list</span></dt><dd><p>dims[n] is the set of dimensions associated with node n+1.</p>
</dd>
<dt><strong>internal_nodes</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Indices of internal (non leaf) nodes.</p>
</dd>
<dt><strong>is_leaf</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>is_leaf[n] = True if the (n+1)th node is a leaf and False otherwise.</p>
</dd>
<dt><strong>level</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>level[n] is the level of the (n+1)th node.</p>
</dd>
<dt><strong>nb_nodes</strong><span class="classifier">int</span></dt><dd><p>Number of nodes.</p>
</dd>
<dt><strong>nodes_parent_of_leaves</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Indices of nodes which are parents of leaves.</p>
</dd>
<dt><strong>_parent</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>_parent[n] is the index of the parent of the (n+1)th node.</p>
</dd>
<dt><strong>root</strong><span class="classifier">numpy.int64</span></dt><dd><p>Index of the root node.</p>
</dd>
<dt><strong>sibling</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>sibling[:,n] contains the indices of the children of the parent of
the (n+1)th node.</p>
</dd>
<dt><strong>nodes_indices</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Indices of the nodes of the tree.</p>
</dd>
<dt><strong>plot_options</strong><span class="classifier">dict</span></dt><dd><p>Options for plotting the tree.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.ascendants" title="tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.ascendants"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ascendants</span></code></a>(nod)</p></td>
<td><p>Return the ascendants of a given node.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.balanced" title="tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.balanced"><code class="xref py py-obj docutils literal notranslate"><span class="pre">balanced</span></code></a>(order)</p></td>
<td><p>Create a balanced dimension tree.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.child_number" title="tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.child_number"><code class="xref py py-obj docutils literal notranslate"><span class="pre">child_number</span></code></a>(nod)</p></td>
<td><p>Return the child number of nod.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.children" title="tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.children"><code class="xref py py-obj docutils literal notranslate"><span class="pre">children</span></code></a>(nod)</p></td>
<td><p>Return the children of a given node.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.descendants" title="tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.descendants"><code class="xref py py-obj docutils literal notranslate"><span class="pre">descendants</span></code></a>(nod)</p></td>
<td><p>Return the descendants of a given node.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.ipermute" title="tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.ipermute"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ipermute</span></code></a>(sigma)</p></td>
<td><p>Inverse permutation of the dimensions of the DimensionTree.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.linear" title="tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.linear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linear</span></code></a>(order)</p></td>
<td><p>Create a linear dimension tree.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.node_with_dims" title="tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.node_with_dims"><code class="xref py py-obj docutils literal notranslate"><span class="pre">node_with_dims</span></code></a>(dims)</p></td>
<td><p>Return the index of the node with given set of dimensions.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.nodes_with_level" title="tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.nodes_with_level"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nodes_with_level</span></code></a>(level)</p></td>
<td><p>Return the indices of the nodes at a given level.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.parent" title="tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.parent"><code class="xref py py-obj docutils literal notranslate"><span class="pre">parent</span></code></a>(nod)</p></td>
<td><p>Return the parent of a given node.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.permute" title="tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.permute"><code class="xref py py-obj docutils literal notranslate"><span class="pre">permute</span></code></a>(sigma)</p></td>
<td><p>Permute the dimensions of the DimensionTree.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.plot" title="tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.plot"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot</span></code></a>(**args)</p></td>
<td><p>Plot the tree with the nodes indices.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.plot_dims" title="tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.plot_dims"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_dims</span></code></a>([nodes])</p></td>
<td><p>Plot the dimensions associated with the nodes of the tree.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.plot_with_labels_at_nodes" title="tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.plot_with_labels_at_nodes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_with_labels_at_nodes</span></code></a>(labels[, …])</p></td>
<td><p>Plot the tree with labels at nodes.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.random" title="tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.random"><code class="xref py py-obj docutils literal notranslate"><span class="pre">random</span></code></a>(order[, arity])</p></td>
<td><p>Create a random dimension tree over {1,…,order}.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.sub_dimension_tree" title="tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.sub_dimension_tree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sub_dimension_tree</span></code></a>(root)</p></td>
<td><p>Extract a sub dimension tree.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.tree_layout" title="tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.tree_layout"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tree_layout</span></code></a>()</p></td>
<td><p>Return the layout of a tree.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.trivial" title="tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.trivial"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trivial</span></code></a>(order)</p></td>
<td><p>Create a dimension tree with one level.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.update_dims_from_leaves" title="tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.update_dims_from_leaves"><code class="xref py py-obj docutils literal notranslate"><span class="pre">update_dims_from_leaves</span></code></a>()</p></td>
<td><p>Update the dimensions of all nodes from the dimensions of the leaves given in T.dim2ind.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.ascendants">
<code class="sig-name descname"><span class="pre">ascendants</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nod</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.ascendants" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the ascendants of a given node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nod</strong><span class="classifier">int</span></dt><dd><p>Node for which to compute the ascendants.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>anod</strong><span class="classifier">list</span></dt><dd><p>List of ascendants of nod.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.balanced">
<em class="property"><span class="pre">static</span> </em><code class="sig-name descname"><span class="pre">balanced</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">order</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.balanced" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a balanced dimension tree.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>order</strong><span class="classifier">int</span></dt><dd><p>Order of the tensor (dimension).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DimensionTree</dt><dd><p>Balanced dimension tree.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.child_number">
<code class="sig-name descname"><span class="pre">child_number</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nod</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.child_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the child number of nod.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nod</strong><span class="classifier">int</span></dt><dd><p>Node for which to compute the child number.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>int</dt><dd><p>The child number.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.children">
<code class="sig-name descname"><span class="pre">children</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nod</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.children" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the children of a given node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nod</strong><span class="classifier">int</span></dt><dd><p>Node for which to compute the children.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>list</dt><dd><p>List of children of nod.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.descendants">
<code class="sig-name descname"><span class="pre">descendants</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nod</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.descendants" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the descendants of a given node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nod</strong><span class="classifier">int</span></dt><dd><p>Node for which to compute the descendants.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dnod</strong><span class="classifier">list</span></dt><dd><p>List of descendants of nod.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.ipermute">
<code class="sig-name descname"><span class="pre">ipermute</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sigma</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.ipermute" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse permutation of the dimensions of the DimensionTree.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sigma</strong><span class="classifier">list</span></dt><dd><p>Indicates the permutation of the dimensions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DimensionTree</dt><dd><p>A DimensionTree with permuted dimensions.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.linear">
<em class="property"><span class="pre">static</span> </em><code class="sig-name descname"><span class="pre">linear</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">order</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a linear dimension tree.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>order</strong><span class="classifier">int</span></dt><dd><p>Order of the tensor (dimension).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DimensionTree</dt><dd><p>Linear dimension tree.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.node_with_dims">
<code class="sig-name descname"><span class="pre">node_with_dims</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.node_with_dims" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the node with given set of dimensions.</p>
<p>Return the index of the node corresponding to dimensions dims or an
empty array if no node contains these dimensions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list or numpy.ndarray</span></dt><dd><p>List of dimensions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>Index of the node with the given set of dimensions dims.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.nodes_with_level">
<code class="sig-name descname"><span class="pre">nodes_with_level</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">level</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.nodes_with_level" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the indices of the nodes at a given level.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>level</strong><span class="classifier">int</span></dt><dd><p>Level.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>Nodes with given level.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.parent">
<code class="sig-name descname"><span class="pre">parent</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nod</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.parent" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the parent of a given node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nod</strong><span class="classifier">int</span></dt><dd><p>Node for which to compute the parent.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>int</dt><dd><p>The parent of nod.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.permute">
<code class="sig-name descname"><span class="pre">permute</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sigma</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.permute" title="Permalink to this definition">¶</a></dt>
<dd><p>Permute the dimensions of the DimensionTree.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sigma</strong><span class="classifier">list</span></dt><dd><p>Indicates the permutation of the dimensions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DimensionTree</dt><dd><p>A DimensionTree with permuted dimensions.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.plot">
<code class="sig-name descname"><span class="pre">plot</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the tree with the nodes indices.</p>
<p>This method requires the package igraph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>node_color</strong><span class="classifier">str, optional</span></dt><dd><p>Color for the colored nodes. The default is ‘red’.</p>
</dd>
<dt><strong>colored_nodes</strong><span class="classifier">list or numpy.ndarray, optional</span></dt><dd><p>Colored nodes. The default is [].</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.plot_dims">
<code class="sig-name descname"><span class="pre">plot_dims</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nodes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.plot_dims" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the dimensions associated with the nodes of the tree.</p>
<p>This method requires the package igraph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nodes</strong><span class="classifier">list or numpy.ndarray, optional</span></dt><dd><p>List of leaf nodes for which to display the dimensions. The
default is None, the dimensions of all the leaf nodes are
displayed.</p>
</dd>
<dt><strong>Returns</strong></dt><dd></dd>
<dt><strong>——-</strong></dt><dd></dd>
<dt><strong>None.</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.plot_with_labels_at_nodes">
<code class="sig-name descname"><span class="pre">plot_with_labels_at_nodes</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'red'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colored_nodes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.plot_with_labels_at_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the tree with labels at nodes.</p>
<p>This method requires the package igraph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>labels</strong><span class="classifier">list or numpy.ndarray</span></dt><dd><p>Nodes labels.</p>
</dd>
<dt><strong>node_color</strong><span class="classifier">str, optional</span></dt><dd><p>Color for the colored nodes. The default is ‘red’.</p>
</dd>
<dt><strong>colored_nodes</strong><span class="classifier">list or numpy.ndarray, optional</span></dt><dd><p>Colored nodes. The default is [].</p>
</dd>
<dt><strong>title</strong><span class="classifier">str, optional</span></dt><dd><p>The title of the plot. The default is None.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.random">
<em class="property"><span class="pre">static</span> </em><code class="sig-name descname"><span class="pre">random</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.random" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a random dimension tree over {1,…,order}.</p>
<p>If arity is an interval [amin,amin], then the number of children of a
node is randomly drawn from the uniform distribution over
{amin,…,amax}.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>order</strong><span class="classifier">int</span></dt><dd><p>Order of the tensor (dimension).</p>
</dd>
<dt><strong>arity</strong><span class="classifier">int, list or numpy.ndarray, optional</span></dt><dd><p>Arity or interval for the arity. The default is 2.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DimensionTree</dt><dd><p>Random dimension tree.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.sub_dimension_tree">
<code class="sig-name descname"><span class="pre">sub_dimension_tree</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">root</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.sub_dimension_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract a sub dimension tree.</p>
<p>The attribute dim2ind of the sub dimension tree gives the nodes indices
corresponding to the dimensions in T.dims[r] (not sorted).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>root</strong><span class="classifier">int</span></dt><dd><p>Index of the node which is the root of the sub dimension tree.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DimensionTree</dt><dd><p>Sub dimension tree.</p>
</dd>
<dt><strong>nod</strong><span class="classifier">np.array</span></dt><dd><p>Extracted nodes from T.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.tree_layout">
<code class="sig-name descname"><span class="pre">tree_layout</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.tree_layout" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the layout of a tree.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>dict</dt><dd><p>The layout of the tree, used for plotting.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.trivial">
<em class="property"><span class="pre">static</span> </em><code class="sig-name descname"><span class="pre">trivial</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">order</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.trivial" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a dimension tree with one level.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>order</strong><span class="classifier">int</span></dt><dd><p>Order of the tensor (dimension).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DimensionTree</dt><dd><p>Trivial dimension tree.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.update_dims_from_leaves">
<code class="sig-name descname"><span class="pre">update_dims_from_leaves</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.dimension_tree.DimensionTree.update_dims_from_leaves" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the dimensions of all nodes from the dimensions of the leaves
given in T.dim2ind.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>DimensionTree</dt><dd><p>The DimensionTree object with updated attribute dims.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-tensap.tensor_algebra.tensors.full_tensor">
<span id="tensap-tensor-algebra-tensors-full-tensor-module"></span><h2>tensap.tensor_algebra.tensors.full_tensor module<a class="headerlink" href="#module-tensap.tensor_algebra.tensors.full_tensor" title="Permalink to this headline">¶</a></h2>
<p>Module full_tensor.</p>
<dl class="py class">
<dt id="tensap.tensor_algebra.tensors.full_tensor.FullTensor">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">tensap.tensor_algebra.tensors.full_tensor.</span></code><code class="sig-name descname"><span class="pre">FullTensor</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Class FullTensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>The content of the tensor.</p>
</dd>
<dt><a class="reference internal" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.order" title="tensap.tensor_algebra.tensors.full_tensor.FullTensor.order"><code class="xref py py-obj docutils literal notranslate"><span class="pre">order</span></code></a><span class="classifier">int</span></dt><dd><p>Compute the order of the tensor.</p>
</dd>
<dt><a class="reference internal" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.shape" title="tensap.tensor_algebra.tensors.full_tensor.FullTensor.shape"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shape</span></code></a><span class="classifier">numpy.ndarray</span></dt><dd><p>Compute the shape of the tensor</p>
</dd>
<dt><strong>is_orth</strong><span class="classifier">bool</span></dt><dd><p>Boolean indicating if the representation of the tensor is orthogonal
(i.e. one mu-matricization is orthogonal).</p>
</dd>
<dt><strong>orth_dim</strong><span class="classifier">bool</span></dt><dd><p>Boolean indicating, if is_orth = True, the dimension mu for which
the mu-matricization of the tensor is orthogonal.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.alpha_principal_components" title="tensap.tensor_algebra.tensors.full_tensor.FullTensor.alpha_principal_components"><code class="xref py py-obj docutils literal notranslate"><span class="pre">alpha_principal_components</span></code></a>(alpha[, parameter])</p></td>
<td><p>Compute the alpha-principal components of a tensor.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.cat" title="tensap.tensor_algebra.tensors.full_tensor.FullTensor.cat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cat</span></code></a>(tensor2[, dims])</p></td>
<td><p>Concatenate the tensors.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.create" title="tensap.tensor_algebra.tensors.full_tensor.FullTensor.create"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create</span></code></a>(generator, shape)</p></td>
<td><p>Create a FullTensor of shape shape using a given generator.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.diag" title="tensap.tensor_algebra.tensors.full_tensor.FullTensor.diag"><code class="xref py py-obj docutils literal notranslate"><span class="pre">diag</span></code></a>(diag, order)</p></td>
<td><p>Create a diagonal tensor x of order order, such that x[i, …, i] = diag[i] for i = 0, …, diag.size - 1.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.dot" title="tensap.tensor_algebra.tensors.full_tensor.FullTensor.dot"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dot</span></code></a>(tensor2)</p></td>
<td><p>Return the inner product of two tensors.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.dot_with_rank_one_metric" title="tensap.tensor_algebra.tensors.full_tensor.FullTensor.dot_with_rank_one_metric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dot_with_rank_one_metric</span></code></a>(tensor2, matrix)</p></td>
<td><p>Compute the weighted inner product of two tensors.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.eval_at_indices" title="tensap.tensor_algebra.tensors.full_tensor.FullTensor.eval_at_indices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval_at_indices</span></code></a>(indices[, dims])</p></td>
<td><p>Evaluate the tensor at indices.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.eval_diag" title="tensap.tensor_algebra.tensors.full_tensor.FullTensor.eval_diag"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval_diag</span></code></a>([dims])</p></td>
<td><p>Extract the diagonal of the tensor.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.full" title="tensap.tensor_algebra.tensors.full_tensor.FullTensor.full"><code class="xref py py-obj docutils literal notranslate"><span class="pre">full</span></code></a>()</p></td>
<td><p>Return the tensor.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.hadamard_product" title="tensap.tensor_algebra.tensors.full_tensor.FullTensor.hadamard_product"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hadamard_product</span></code></a>(arg)</p></td>
<td><p>Compute the Hadamard product of two tensors.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.itranspose" title="tensap.tensor_algebra.tensors.full_tensor.FullTensor.itranspose"><code class="xref py py-obj docutils literal notranslate"><span class="pre">itranspose</span></code></a>(dims)</p></td>
<td><p>Return the inverse transpose (permutation) of the dimensions of the tensor.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.kron" title="tensap.tensor_algebra.tensors.full_tensor.FullTensor.kron"><code class="xref py py-obj docutils literal notranslate"><span class="pre">kron</span></code></a>(tensor2)</p></td>
<td><p>Kronecker product of tensors.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.matricize" title="tensap.tensor_algebra.tensors.full_tensor.FullTensor.matricize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">matricize</span></code></a>(dims1[, dims2])</p></td>
<td><p>Return the matricization of the tensor.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.norm" title="tensap.tensor_algebra.tensors.full_tensor.FullTensor.norm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">norm</span></code></a>()</p></td>
<td><p>Compute the canonical norm of the FullTensor.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.numpy" title="tensap.tensor_algebra.tensors.full_tensor.FullTensor.numpy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span></code></a>()</p></td>
<td><p>Convert the FullTensor to a numpy.ndarray.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.ones" title="tensap.tensor_algebra.tensors.full_tensor.FullTensor.ones"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ones</span></code></a>(shape)</p></td>
<td><p>Create a FullTensor of shape shape with entries equal to 1.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.orth" title="tensap.tensor_algebra.tensors.full_tensor.FullTensor.orth"><code class="xref py py-obj docutils literal notranslate"><span class="pre">orth</span></code></a>([dim])</p></td>
<td><p>Orthogonalize the tensor.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.outer_product_eval_diag" title="tensap.tensor_algebra.tensors.full_tensor.FullTensor.outer_product_eval_diag"><code class="xref py py-obj docutils literal notranslate"><span class="pre">outer_product_eval_diag</span></code></a>(tensor2, dims1, dims2)</p></td>
<td><p>Compute the diagonal of the outer product of two tensors.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.principal_components" title="tensap.tensor_algebra.tensors.full_tensor.FullTensor.principal_components"><code class="xref py py-obj docutils literal notranslate"><span class="pre">principal_components</span></code></a>([parameter])</p></td>
<td><p>Compute the principal components of an order-2 tensor.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.rand" title="tensap.tensor_algebra.tensors.full_tensor.FullTensor.rand"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rand</span></code></a>(shape)</p></td>
<td><p>Create a FullTensor of shape shape with i.i.d.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.randn" title="tensap.tensor_algebra.tensors.full_tensor.FullTensor.randn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">randn</span></code></a>(shape)</p></td>
<td><p>Create a FullTensor of shape shape with i.i.d.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.reduce_mean" title="tensap.tensor_algebra.tensors.full_tensor.FullTensor.reduce_mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reduce_mean</span></code></a>([dims])</p></td>
<td><p>Compute the mean of elements across dimensions dims of a tensor.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.reduce_sum" title="tensap.tensor_algebra.tensors.full_tensor.FullTensor.reduce_sum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reduce_sum</span></code></a>([dims])</p></td>
<td><p>Compute the sum of elements across dimensions dims of a tensor.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.reshape" title="tensap.tensor_algebra.tensors.full_tensor.FullTensor.reshape"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reshape</span></code></a>(shape)</p></td>
<td><p>Reshape the tensor.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.singular_values" title="tensap.tensor_algebra.tensors.full_tensor.FullTensor.singular_values"><code class="xref py py-obj docutils literal notranslate"><span class="pre">singular_values</span></code></a>()</p></td>
<td><p>Compute the higher-order singular values of a tensor (the collection of singular values of d different matricizations).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.sparse" title="tensap.tensor_algebra.tensors.full_tensor.FullTensor.sparse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sparse</span></code></a>()</p></td>
<td><p>Conversion of a FullTensor into a SparseTensor.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.sparse_storage" title="tensap.tensor_algebra.tensors.full_tensor.FullTensor.sparse_storage"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sparse_storage</span></code></a>()</p></td>
<td><p>Return the sparse storage complexity of the FullTensor.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.squeeze" title="tensap.tensor_algebra.tensors.full_tensor.FullTensor.squeeze"><code class="xref py py-obj docutils literal notranslate"><span class="pre">squeeze</span></code></a>([dims])</p></td>
<td><p>Remove the singleton dimensions of the tensor.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.storage" title="tensap.tensor_algebra.tensors.full_tensor.FullTensor.storage"><code class="xref py py-obj docutils literal notranslate"><span class="pre">storage</span></code></a>()</p></td>
<td><p>Return the storage complexity of the FullTensor.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.sub_tensor" title="tensap.tensor_algebra.tensors.full_tensor.FullTensor.sub_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sub_tensor</span></code></a>(*indices)</p></td>
<td><p>Extract a subtensor of the tensor.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.tensor_diagonal_matrix_product" title="tensap.tensor_algebra.tensors.full_tensor.FullTensor.tensor_diagonal_matrix_product"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tensor_diagonal_matrix_product</span></code></a>(matrices[, dims])</p></td>
<td><p>Contract a FullTensor with matrices built from their diagonals.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.tensor_matrix_product" title="tensap.tensor_algebra.tensors.full_tensor.FullTensor.tensor_matrix_product"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tensor_matrix_product</span></code></a>(matrices[, dims])</p></td>
<td><p>Contract a tensor with matrices.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.tensor_matrix_product_eval_diag" title="tensap.tensor_algebra.tensors.full_tensor.FullTensor.tensor_matrix_product_eval_diag"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tensor_matrix_product_eval_diag</span></code></a>(matrices[, dims])</p></td>
<td><p>Evaluate the diagonal of a tensor obtained by contraction with matrices.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.tensor_vector_product" title="tensap.tensor_algebra.tensors.full_tensor.FullTensor.tensor_vector_product"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tensor_vector_product</span></code></a>(vectors[, dims])</p></td>
<td><p>Compute the contraction of the tensor with vectors.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.tensordot" title="tensap.tensor_algebra.tensors.full_tensor.FullTensor.tensordot"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tensordot</span></code></a>(tensor2, dims1[, dims2])</p></td>
<td><p>Contract two tensors along specified dimensions.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.tensordot_eval_diag" title="tensap.tensor_algebra.tensors.full_tensor.FullTensor.tensordot_eval_diag"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tensordot_eval_diag</span></code></a>(tensor2, dims1, dims2, …)</p></td>
<td><p>Evaluate of the diagonal of a tensor obtained by contraction of two tensors.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.tensordot_matrix_product_except_dim" title="tensap.tensor_algebra.tensors.full_tensor.FullTensor.tensordot_matrix_product_except_dim"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tensordot_matrix_product_except_dim</span></code></a>(tensor2, …)</p></td>
<td><p>Particular type of contraction.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.transpose" title="tensap.tensor_algebra.tensors.full_tensor.FullTensor.transpose"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transpose</span></code></a>(dims)</p></td>
<td><p>Transpose (permute) the dimensions of the tensor.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.tree_based_tensor" title="tensap.tensor_algebra.tensors.full_tensor.FullTensor.tree_based_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tree_based_tensor</span></code></a>()</p></td>
<td><p>Convert a FullTensor into a TreeBasedTensor.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.zeros" title="tensap.tensor_algebra.tensors.full_tensor.FullTensor.zeros"><code class="xref py py-obj docutils literal notranslate"><span class="pre">zeros</span></code></a>(shape)</p></td>
<td><p>Create a FullTensor of shape shape with entries equal to 0.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.full_tensor.FullTensor.alpha_principal_components">
<code class="sig-name descname"><span class="pre">alpha_principal_components</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parameter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.alpha_principal_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the alpha-principal components of a tensor.</p>
<p>Return the principal components of the alpha-matricization
M_alpha(self) of the tensor self of order d.</p>
<p>See also the method principal_components.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>alpha</strong><span class="classifier">int</span></dt><dd><p>The index of the alpha-matricization.</p>
</dd>
<dt><strong>parameter</strong><span class="classifier">float or int, optional</span></dt><dd><p>A parameter controlling the number of principal components.
The default is M_alpha(self).shape[0].</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>principal_components</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>The principal components of the tensor.</p>
</dd>
<dt><strong>singular_values</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>The diagonal matrix of the associated singular values.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.full_tensor.FullTensor.cat">
<code class="sig-name descname"><span class="pre">cat</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensor2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.cat" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenate the tensors.</p>
<p>Concatenates self and tensor2 in a tensor z such that:
z(i_1 ,…, i_d) = x(i_1, …, i_d) if i_k &lt;= sz[k]-1 for k in dims,
z(i_1, …, i_d) = y(i_1-sz[0], …, i_d-sz[d-1]) if i_k &gt;= sz[k]
for k in dims,
z(i_1, …, i_d) = 0 otherwise, with sz = self.shape and
dims = range(self.order) if not provided.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tensor2</strong><span class="classifier">FullTensor</span></dt><dd><p>The second tensor to be concatenaed.</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list or numpy.ndarray, optional</span></dt><dd><p>The dimensions of the concatenation. The default is None,
indicating all the dimensions.</p>
</dd>
<dt><strong>Returns</strong></dt><dd></dd>
<dt><strong>——-</strong></dt><dd></dd>
<dt><strong>data</strong><span class="classifier">FullTensor</span></dt><dd><p>The concatenated tensors.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.full_tensor.FullTensor.create">
<em class="property"><span class="pre">static</span> </em><code class="sig-name descname"><span class="pre">create</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">generator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a FullTensor of shape shape using a given generator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>generator</strong><span class="classifier">function</span></dt><dd><p>Function generating a numpy.ndarray, given a shape.</p>
</dd>
<dt><strong>shape</strong><span class="classifier">numpy.ndarray or list</span></dt><dd><p>The shape of the tensor.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>FullTensor</dt><dd><p>The created tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.full_tensor.FullTensor.diag">
<em class="property"><span class="pre">static</span> </em><code class="sig-name descname"><span class="pre">diag</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">diag</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.diag" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a diagonal tensor x of order order, such that
x[i, …, i] = diag[i] for i = 0, …, diag.size - 1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>diag</strong><span class="classifier">list or numpy.ndarray</span></dt><dd><p>The diagonal of the tensor.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int</span></dt><dd><p>The order of the tensor.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>FullTensor</dt><dd><p>The created tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.full_tensor.FullTensor.dot">
<code class="sig-name descname"><span class="pre">dot</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensor2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the inner product of two tensors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tensor2</strong><span class="classifier">FullTensor</span></dt><dd><p>The second tensor of the inner products.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.float</dt><dd><p>The inner product of the two tensors.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.full_tensor.FullTensor.dot_with_rank_one_metric">
<code class="sig-name descname"><span class="pre">dot_with_rank_one_metric</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensor2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">matrix</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.dot_with_rank_one_metric" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the weighted inner product of two tensors.</p>
<p>Compute the weighted canonical inner product of self and tensor2,
where the inner product related to dimension k is weighted by
matrix[k]. It is equivalent to
self.dot(tensor2.tensor_matrix_product(matrix)),
but can be much faster.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tensor2</strong><span class="classifier">FullTensor</span></dt><dd><p>The second tensor of the inner product.</p>
</dd>
<dt><strong>matrix</strong><span class="classifier">list or numpy.ndarray or FullTensor</span></dt><dd><p>The weight matrix.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.float</dt><dd><p>The weighted inner product.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.full_tensor.FullTensor.eval_at_indices">
<code class="sig-name descname"><span class="pre">eval_at_indices</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.eval_at_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the tensor at indices.</p>
<p>If dims is None, return
s(k) = x(indices(k, 1), indices(k, 2), …, indices(k, d)),
1 &lt;= k &lt;= self.shape[0].</p>
<p>If dims is not None, return a partial evaluation: up to a permutation
(placing the dimensions dims on the left), return
s(k, i_1, …, i_d’) = x(indices(k, 1), indices(k, 2), …,
indices(k, M), i_1, …, i_d’),
1 &lt;= k &lt;= self.shape[0], with M = dims.size and d’ = self.order - M.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>indices</strong><span class="classifier">list of numpy.ndarray</span></dt><dd><p>The indices of the tensor.</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list of numpy.ndarray, optional</span></dt><dd><p>The dimensions associated with the indices. The default is None,
indicating that indices refers to all the dimensions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>evaluations</strong><span class="classifier">numpy.ndarray or FullTensor</span></dt><dd><p>The evaluations of the tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.full_tensor.FullTensor.eval_diag">
<code class="sig-name descname"><span class="pre">eval_diag</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.eval_diag" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract the diagonal of the tensor.</p>
<p>The tensor must be such that self.shape[mu] = n for all mu (in dims if
provided).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list of numpy.ndarray, optional</span></dt><dd><p>The dimensions associated with the indices of the diagonal. The
default is None,indicating that the indices refer to all the
dimensions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>data</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>The evaluations of the diagonal of the tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.full_tensor.FullTensor.full">
<code class="sig-name descname"><span class="pre">full</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.full" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>FullTensor</dt><dd><p>The tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.full_tensor.FullTensor.hadamard_product">
<code class="sig-name descname"><span class="pre">hadamard_product</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arg</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.hadamard_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Hadamard product of two tensors.</p>
<p>Equivalent to self * arg.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>arg</strong><span class="classifier">tensap.FullTensor or numpy.ndarray</span></dt><dd><p>The second tensor of the Hadamard product.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>FullTensor</dt><dd><p>The tensor resulting from the Hadamard product.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.full_tensor.FullTensor.itranspose">
<code class="sig-name descname"><span class="pre">itranspose</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.itranspose" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the inverse transpose (permutation) of the dimensions of the
tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list or numpy.ndarray</span></dt><dd><p>The original transpose (permutation) indices.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>FullTensor</dt><dd><p>The transposed (permuted) tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.full_tensor.FullTensor.kron">
<code class="sig-name descname"><span class="pre">kron</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensor2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.kron" title="Permalink to this definition">¶</a></dt>
<dd><p>Kronecker product of tensors.</p>
<p>Similar to numpy.kron but for arbitrary tensors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tensor2</strong><span class="classifier">FullTensor</span></dt><dd><p>The second tensor of the Kronecker product.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>FullTensor</dt><dd><p>The tensor resulting from the Kronecker product.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.full_tensor.FullTensor.matricize">
<code class="sig-name descname"><span class="pre">matricize</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.matricize" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the matricization of the tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims1</strong><span class="classifier">list or numpy.ndarray</span></dt><dd><p>The dimensions of the tensor corresponding to the first dimension
of the matricization.</p>
</dd>
<dt><strong>dims2</strong><span class="classifier">list or numpy.ndarray, optional</span></dt><dd><p>The dimensions of the tensor corresponding to the first dimension
of the matricization. The default is None, for which they are
deduced from dims1.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>FullTensor</dt><dd><p>The matricization of the tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.full_tensor.FullTensor.ndim">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">ndim</span></code><a class="headerlink" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.ndim" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the order of the tensor. Equivalent to self.order.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>int</dt><dd><p>The order of the tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.full_tensor.FullTensor.norm">
<code class="sig-name descname"><span class="pre">norm</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the canonical norm of the FullTensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>numpy.float</dt><dd><p>The norm of the tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.full_tensor.FullTensor.numpy">
<code class="sig-name descname"><span class="pre">numpy</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.numpy" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the FullTensor to a numpy.ndarray.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>The FullTensor as a numpy.ndarray.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.full_tensor.FullTensor.ones">
<em class="property"><span class="pre">static</span> </em><code class="sig-name descname"><span class="pre">ones</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.ones" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a FullTensor of shape shape with entries equal to 1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>shape</strong><span class="classifier">numpy.ndarray or list</span></dt><dd><p>The shape of the tensor.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>FullTensor</dt><dd><p>The created tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.full_tensor.FullTensor.order">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">order</span></code><a class="headerlink" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.order" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the order of the tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>int</dt><dd><p>The order of the tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.full_tensor.FullTensor.orth">
<code class="sig-name descname"><span class="pre">orth</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.orth" title="Permalink to this definition">¶</a></dt>
<dd><p>Orthogonalize the tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dim</strong><span class="classifier">int, optional</span></dt><dd><p>The dimension of the orthogonal dim-matricization of self. The
default is None, returning a copy of the original tensor.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>tensor</strong><span class="classifier">FullTensor</span></dt><dd><p>A tensor whose dim-matricization is an orthogonal matrix
corresponding to the Q factor of a QR factorization of the
dim-matricization of self.</p>
</dd>
<dt><strong>r_matrix</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>The R factor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.full_tensor.FullTensor.outer_product_eval_diag">
<code class="sig-name descname"><span class="pre">outer_product_eval_diag</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensor2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.outer_product_eval_diag" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the diagonal of the outer product of two tensors.</p>
<p>Equivalent to
self.tensordot_eval_diag(tensor2, None, None, dims1, dims2, diag)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tensor2</strong><span class="classifier">FullTensor</span></dt><dd><p>The second tensor of the product.</p>
</dd>
<dt><strong>dims1</strong><span class="classifier">list or numpy.ndarray</span></dt><dd><p>Indices of the first tensor for the evaluation of the diagonal.</p>
</dd>
<dt><strong>dims2</strong><span class="classifier">list or numpy.ndarray,</span></dt><dd><p>Indices of the second tensor for the evaluation of the diagonal.</p>
</dd>
<dt><strong>diag</strong><span class="classifier">bool, optional</span></dt><dd><p>Boolean enabling the evaluation of multiple diagonals. The default
is False.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>FullTensor</dt><dd><p>The evaluated tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.full_tensor.FullTensor.principal_components">
<code class="sig-name descname"><span class="pre">principal_components</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">parameter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.principal_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the principal components of an order-2 tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>parameter</strong><span class="classifier">float or int, optional</span></dt><dd><p>A parameter controlling the number of principal components.
- If it is an integer, the number of principal components is the
minimum between parameter and self.shape[0].
- If it is a float smaller than 1, the number of principal
components is determined such that ||x - VV’x||_F &lt; t ||x||_F,
with x the tensor, V the matrix of principal components, t the
parameter, V’ the transpose of the matrix V and ||.||_F the
Frobenius norm.
The default is self.shape[0].</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>principal_components</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>The principal components of the tensor.</p>
</dd>
<dt><strong>singular_values</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>The diagonal matrix of the associated singular values.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.full_tensor.FullTensor.rand">
<em class="property"><span class="pre">static</span> </em><code class="sig-name descname"><span class="pre">rand</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.rand" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a FullTensor of shape shape with i.i.d. entries drawn according
to the uniform distribution on [0, 1].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>shape</strong><span class="classifier">numpy.ndarray or list</span></dt><dd><p>The shape of the tensor.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>FullTensor</dt><dd><p>The created tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.full_tensor.FullTensor.randn">
<em class="property"><span class="pre">static</span> </em><code class="sig-name descname"><span class="pre">randn</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.randn" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a FullTensor of shape shape with i.i.d. entries drawn according
to the standard gaussian distribution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>shape</strong><span class="classifier">numpy.ndarray or list</span></dt><dd><p>The shape of the tensor.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>FullTensor</dt><dd><p>The created tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.full_tensor.FullTensor.reduce_mean">
<code class="sig-name descname"><span class="pre">reduce_mean</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.reduce_mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the mean of elements across dimensions dims of a tensor.</p>
<p>Similar to tensorflow.mean.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list or numpy.ndarray, optional</span></dt><dd><p>The dimensions to be reduced. The default is None, indicating all
the dimensions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>FullTensor</dt><dd><p>The reduced tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.full_tensor.FullTensor.reduce_sum">
<code class="sig-name descname"><span class="pre">reduce_sum</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.reduce_sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the sum of elements across dimensions dims of a tensor.</p>
<p>Similar to tensorflow.reduce_sum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list or numpy.ndarray, optional</span></dt><dd><p>The dimensions to be reduced. The default is None, indicating all
the dimensions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>FullTensor</dt><dd><p>The reduced tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.full_tensor.FullTensor.reshape">
<code class="sig-name descname"><span class="pre">reshape</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.reshape" title="Permalink to this definition">¶</a></dt>
<dd><p>Reshape the tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>shape</strong><span class="classifier">list or numpy.ndarray</span></dt><dd><p>The new shape of the tensor.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>tensor</strong><span class="classifier">FullTensor</span></dt><dd><p>The reshaped tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.full_tensor.FullTensor.shape">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">shape</span></code><a class="headerlink" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the shape of the tensor</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>The shape of the tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.full_tensor.FullTensor.singular_values">
<code class="sig-name descname"><span class="pre">singular_values</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.singular_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the higher-order singular values of a tensor (the collection
of singular values of d different matricizations).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sin_val</strong><span class="classifier">numpy.ndarray or list of numpy.ndarray.</span></dt><dd><p>The higher-order singular values.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.full_tensor.FullTensor.size">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">size</span></code><a class="headerlink" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the number of elements of the tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>The number of elements of the tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.full_tensor.FullTensor.sparse">
<code class="sig-name descname"><span class="pre">sparse</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.sparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Conversion of a FullTensor into a SparseTensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>tensap.SparseTensor</dt><dd><p>A SparseTensor representation of the FullTensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.full_tensor.FullTensor.sparse_storage">
<code class="sig-name descname"><span class="pre">sparse_storage</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.sparse_storage" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sparse storage complexity of the FullTensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>int</dt><dd><p>The sparse storage complexity of the FullTensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.full_tensor.FullTensor.squeeze">
<code class="sig-name descname"><span class="pre">squeeze</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.squeeze" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the singleton dimensions of the tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list or numpy.ndarray, optional</span></dt><dd><p>Dimensions to squeeze. The default is None, indicating all the
singleton dimensions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">float or FullTensor</span></dt><dd><p>The squeezed tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.full_tensor.FullTensor.storage">
<code class="sig-name descname"><span class="pre">storage</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.storage" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the storage complexity of the FullTensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>int</dt><dd><p>The storage complexity of the FullTensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.full_tensor.FullTensor.sub_tensor">
<code class="sig-name descname"><span class="pre">sub_tensor</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">indices</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.sub_tensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract a subtensor of the tensor.</p>
<p>The result is a tensor s of shape
len(indices[0]), …, len(indices[self.order-1]),
such that
s(k1,…,kd) = x(indices[0][k1], …, indices[self.order-1][kd]).</p>
<p>Example: x.subTensor([1, 2], ‘:’, [2, 5, 6]) returns a tensor with
shape [2, self.shape[1], 3].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>*indices</strong><span class="classifier">list</span></dt><dd><p>The indices to extract in each dimension. ‘:’ indicates all the
indices.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>FullTensor</dt><dd><p>The subtensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.full_tensor.FullTensor.tensor_diagonal_matrix_product">
<code class="sig-name descname"><span class="pre">tensor_diagonal_matrix_product</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.tensor_diagonal_matrix_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Contract a FullTensor with matrices built from their diagonals.</p>
<p>The second dimension of the matrix matrices[k] is contracted with the
k-th dimension of self, with the indices k given in dims (if provided).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>matrices</strong><span class="classifier">numpy.ndarray or list of numpy.ndarray</span></dt><dd><p>The diagonals of the matrices to use in the product.</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list or numpy.ndarray, optional</span></dt><dd><p>Indices of the contractions. The default is None, indicating all
the dimensions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>FullTensor</dt><dd><p>The tensor after the contractions with the matrices.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.full_tensor.FullTensor.tensor_matrix_product">
<code class="sig-name descname"><span class="pre">tensor_matrix_product</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.tensor_matrix_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Contract a tensor with matrices.</p>
<p>The second dimension of the matrix matrices[k] is contracted with the
k-th dimension of self, with the indices k given in dims (if provided).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>matrices</strong><span class="classifier">numpy.ndarray or list of numpy.ndarray</span></dt><dd><p>The matrices to use in the product.</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list or numpy.ndarray, optional</span></dt><dd><p>Indices of the contractions. The default is None, indicating all
the dimensions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>FullTensor</dt><dd><p>The tensor after the contractions with the matrices.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.full_tensor.FullTensor.tensor_matrix_product_eval_diag">
<code class="sig-name descname"><span class="pre">tensor_matrix_product_eval_diag</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.tensor_matrix_product_eval_diag" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the diagonal of a tensor obtained by contraction with
matrices.</p>
<p>Provides the diagonal of the tensor obtained by contracting the tensor
with matrices H[k] along dimensions dims(k)+1, for k = 0, …,
dims.size-1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>matrices</strong><span class="classifier">list</span></dt><dd><p>The matrices to use in the product.</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list or numpy.ndarray, optional</span></dt><dd><p>Indices of the contractions. The default is None, indicating all
the dimensions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">FullTensor</span></dt><dd><p>The diagonal of the contractions of the tensor with the matrices.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.full_tensor.FullTensor.tensor_vector_product">
<code class="sig-name descname"><span class="pre">tensor_vector_product</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vectors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.tensor_vector_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the contraction of the tensor with vectors.</p>
<p>Compute the contraction of self with each vector contained in the list
vectors along dimensions specified by dims. The operation is such that
V[k] is contracted with the dims[k]-th dimension of self.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vectors</strong><span class="classifier">numpy.ndarray or list of numpy.ndarray</span></dt><dd><p>The vectors to use in the product.</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list or numpy.ndarray, optional</span></dt><dd><p>Indices of the contractions. The default is None, indicating all
the dimensions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>FullTensor</dt><dd><p>The tensor after the contractions with the vectors.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.full_tensor.FullTensor.tensordot">
<code class="sig-name descname"><span class="pre">tensordot</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensor2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.tensordot" title="Permalink to this definition">¶</a></dt>
<dd><p>Contract two tensors along specified dimensions.</p>
<p>Similar to tensorflow.tensordot.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tensor2</strong><span class="classifier">FullTensor</span></dt><dd><p>The second tensor of the contraction.</p>
</dd>
<dt><strong>dims1</strong><span class="classifier">list or int</span></dt><dd><p>The dimensions of contractions for the first tensor.</p>
</dd>
<dt><strong>dims2</strong><span class="classifier">list or int, optional</span></dt><dd><p>The dimensions of contractions for the second tensor. The default
is None which indicates, if dims1 = 0, to perform the outer
product of the two tensors, similarly to tensorflow.tensordot.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">FullTensor</span></dt><dd><p>The resulting tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.full_tensor.FullTensor.tensordot_eval_diag">
<code class="sig-name descname"><span class="pre">tensordot_eval_diag</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensor2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diag_dims1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diag_dims2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.tensordot_eval_diag" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate of the diagonal of a tensor obtained by contraction of two
tensors.</p>
<p>The contraction is performed along the dimensions dims1 for self and
dims2 for tensor2, and the diagonal is evaluated according to the
dimensions diag_dims1 for self and diag_dims2 for tensor2.</p>
<p>The boolean diag indicates if the several diagonals are evaluated, for
instance:
- if diag is False, for order-4 tensors x and y,
z = x.tensordot_eval_diag(y,[1,3],[2,3],2,0) returns an order-3 tensor
z(i1,k,j2) = sum_{l1,l2} x(i1,l1,k,l2) y(k,j2,l1,l2)
- if diag is True, for order-5 tensors x and y,
z = x.tensordot_eval_diag(y,[1,3],[2,3],[0,2],[1,4]) returns an
order-4 tensor
z(k,l,i5,j1) = sum_{l1,l2} x(k,l1,l,l2,i5) y(j1,k,l1,l2,l)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tensor2</strong><span class="classifier">FullTensor</span></dt><dd><p>The second tensor of the product.</p>
</dd>
<dt><strong>dims1</strong><span class="classifier">list or numpy.ndarray</span></dt><dd><p>Dimensions of the first tensor for the contraction.</p>
</dd>
<dt><strong>dims2</strong><span class="classifier">list or numpy.ndarray</span></dt><dd><p>Dimensions of the second tensor for the contraction.</p>
</dd>
<dt><strong>diag_dims1</strong><span class="classifier">list or numpy.ndarray</span></dt><dd><p>Indices of the first tensor for the evaluation of the diagonal.</p>
</dd>
<dt><strong>diag_dims2</strong><span class="classifier">list or numpy.ndarray</span></dt><dd><p>Indices of the second tensor for the evaluation of the diagonal.</p>
</dd>
<dt><strong>diag</strong><span class="classifier">bool, optional</span></dt><dd><p>Boolean enabling the evaluation of multiple diagonals. The default
is False.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>FullTensor</dt><dd><p>The evaluated tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.full_tensor.FullTensor.tensordot_matrix_product_except_dim">
<code class="sig-name descname"><span class="pre">tensordot_matrix_product_except_dim</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensor2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">matrices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.tensordot_matrix_product_except_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Particular type of contraction.</p>
<p>Compute a special contraction of two tensors self, tensor2, a list of
matrices matrices and a particular dimension dim. Note that dim must
be a scalar, while matrices must be a list array with self.order
elements.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tensor2</strong><span class="classifier">FullTensor</span></dt><dd><p>The second tensor of the contraction.</p>
</dd>
<dt><strong>matrices</strong><span class="classifier">list</span></dt><dd><p>The list of matrices of the contraction.</p>
</dd>
<dt><strong>dim</strong><span class="classifier">int</span></dt><dd><p>The excluded dimension.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>The result of the contraction.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.full_tensor.FullTensor.transpose">
<code class="sig-name descname"><span class="pre">transpose</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>Transpose (permute) the dimensions of the tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list or numpy.ndarray</span></dt><dd><p>The new ordering of the dimensions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>tensor</strong><span class="classifier">FullTensor</span></dt><dd><p>The transposed (permuted) tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.full_tensor.FullTensor.tree_based_tensor">
<code class="sig-name descname"><span class="pre">tree_based_tensor</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.tree_based_tensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a FullTensor into a TreeBasedTensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>TreeBasedTensor</dt><dd><p>The FullTensor in tree-based tensor format.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.full_tensor.FullTensor.zeros">
<em class="property"><span class="pre">static</span> </em><code class="sig-name descname"><span class="pre">zeros</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.full_tensor.FullTensor.zeros" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a FullTensor of shape shape with entries equal to 0.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>shape</strong><span class="classifier">numpy.ndarray or list</span></dt><dd><p>The shape of the tensor.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>FullTensor</dt><dd><p>The created tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-tensap.tensor_algebra.tensors.sparse_tensor">
<span id="tensap-tensor-algebra-tensors-sparse-tensor-module"></span><h2>tensap.tensor_algebra.tensors.sparse_tensor module<a class="headerlink" href="#module-tensap.tensor_algebra.tensors.sparse_tensor" title="Permalink to this headline">¶</a></h2>
<p>Module sparse_tensor.</p>
<dl class="py class">
<dt id="tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">tensap.tensor_algebra.tensors.sparse_tensor.</span></code><code class="sig-name descname"><span class="pre">SparseTensor</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Class SparseTensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>The values of the tensor at the entries in indices.</p>
</dd>
<dt><strong>indices</strong><span class="classifier">tensap.MultiIndices</span></dt><dd><p>The set of multi-indices corresponding to the non-zero coefficients of
the tensor.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int</span></dt><dd><p>The order of the tensor.</p>
</dd>
<dt><strong>shape</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>The shape of the tensor.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.cat" title="tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.cat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cat</span></code></a>(y, dims)</p></td>
<td><p>Concatenate the tensors.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.count_non_zero" title="tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.count_non_zero"><code class="xref py py-obj docutils literal notranslate"><span class="pre">count_non_zero</span></code></a>()</p></td>
<td><p>Return the number of non-zero coefficients of the SparseTensor.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.dot" title="tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.dot"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dot</span></code></a>(y)</p></td>
<td><p>Return the inner product of two tensors.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.dot_with_rank_one_metric" title="tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.dot_with_rank_one_metric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dot_with_rank_one_metric</span></code></a>(y, M)</p></td>
<td><p>Compute the weighted inner product of two tensors.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.eval_at_indices" title="tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.eval_at_indices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval_at_indices</span></code></a>(ind[, dims])</p></td>
<td><p>Evaluate the tensor at indices.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.eval_diag" title="tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.eval_diag"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval_diag</span></code></a>([dims])</p></td>
<td><p>Extract the diagonal of the tensor.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.full" title="tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.full"><code class="xref py py-obj docutils literal notranslate"><span class="pre">full</span></code></a>()</p></td>
<td><p>Convert the SparseTensor to a tensap.FullTensor.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.itranspose" title="tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.itranspose"><code class="xref py py-obj docutils literal notranslate"><span class="pre">itranspose</span></code></a>(dims)</p></td>
<td><p>Return the inverse transpose (permutation) of the dimensions of the tensor.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.kron" title="tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.kron"><code class="xref py py-obj docutils literal notranslate"><span class="pre">kron</span></code></a>(y)</p></td>
<td><p>Kronecker product of tensors.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.norm" title="tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.norm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">norm</span></code></a>()</p></td>
<td><p>Compute the canonical norm of the SparseTensor.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.numpy" title="tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.numpy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span></code></a>()</p></td>
<td><p>Convert the SparseTensor to a scipy.sparse.lil.lil_matrix, which can be converted to a numpy.matrix using the command todense().</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.orth" title="tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.orth"><code class="xref py py-obj docutils literal notranslate"><span class="pre">orth</span></code></a>(dim)</p></td>
<td><p>Orthogonalize the tensor.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.reshape" title="tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.reshape"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reshape</span></code></a>(shape)</p></td>
<td><p>Reshape the tensor.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.sparse_storage" title="tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.sparse_storage"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sparse_storage</span></code></a>()</p></td>
<td><p>Return the sparse storage complexity of the SparseTensor.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.squeeze" title="tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.squeeze"><code class="xref py py-obj docutils literal notranslate"><span class="pre">squeeze</span></code></a>(dims)</p></td>
<td><p>Remove the singleton dimensions of the tensor.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.storage" title="tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.storage"><code class="xref py py-obj docutils literal notranslate"><span class="pre">storage</span></code></a>()</p></td>
<td><p>Return the storage complexity of the SparseTensor.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.sub_tensor" title="tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.sub_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sub_tensor</span></code></a>(*indices)</p></td>
<td><p>Extract a subtensor of the tensor.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.tensor_diagonal_matrix_product" title="tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.tensor_diagonal_matrix_product"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tensor_diagonal_matrix_product</span></code></a>(matrices[, dims])</p></td>
<td><p>Contract a SparseTensor with matrices built from their diagonals.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.tensor_matrix_product" title="tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.tensor_matrix_product"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tensor_matrix_product</span></code></a>(matrices[, dims])</p></td>
<td><p>Contract a tensor with matrices.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.tensor_matrix_product_eval_diag" title="tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.tensor_matrix_product_eval_diag"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tensor_matrix_product_eval_diag</span></code></a>(matrices)</p></td>
<td><p>Evaluate the diagonal of a tensor obtained by contraction with matrices.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.tensor_vector_product" title="tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.tensor_vector_product"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tensor_vector_product</span></code></a>(vectors[, dims])</p></td>
<td><p>Compute the contraction of the tensor with vectors.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.tensordot_matrix_product_except_dim" title="tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.tensordot_matrix_product_except_dim"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tensordot_matrix_product_except_dim</span></code></a>(y, M, dim)</p></td>
<td><p>Particular type of contraction.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.transpose" title="tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.transpose"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transpose</span></code></a>(dims)</p></td>
<td><p>Transpose (permute) the dimensions of the tensor.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.cat">
<code class="sig-name descname"><span class="pre">cat</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.cat" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenate the tensors.</p>
<p>Concatenates self and y in a tensor z such that:
z(i_1 ,…, i_d) = x(i_1, …, i_d) if i_k &lt;= sz[k]-1 for k in dims,
z(i_1, …, i_d) = y(i_1-sz[0], …, i_d-sz[d-1]) if i_k &gt;= sz[k]
for k in dims,
z(i_1, …, i_d) = 0 otherwise, with sz = self.shape and
dims = range(self.order) if not provided.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>y</strong><span class="classifier">Tensor</span></dt><dd><p>The second tensor to be concatenaed.</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list or numpy.ndarray, optional</span></dt><dd><p>The dimensions of the concatenation. The default is None,
indicating all the dimensions.</p>
</dd>
<dt><strong>Returns</strong></dt><dd></dd>
<dt><strong>——-</strong></dt><dd></dd>
<dt><strong>SparseTensor</strong></dt><dd><p>The concatenated tensors.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.count_non_zero">
<code class="sig-name descname"><span class="pre">count_non_zero</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.count_non_zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of non-zero coefficients of the SparseTensor.
Equivalent to self.sparse_storage().</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>int</dt><dd><p>The number of non-zero coefficients of the SparseTensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.dot">
<code class="sig-name descname"><span class="pre">dot</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the inner product of two tensors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>y</strong><span class="classifier">tensap.Tensor</span></dt><dd><p>The second tensor of the inner products. Must be convertible to
a SparseTensor.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.float</dt><dd><p>The inner product of the two tensors.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.dot_with_rank_one_metric">
<code class="sig-name descname"><span class="pre">dot_with_rank_one_metric</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.dot_with_rank_one_metric" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the weighted inner product of two tensors.</p>
<p>Compute the weighted canonical inner product of self and y,
where the inner product related to dimension k is weighted by
M[k]. It is equivalent to
self.dot(y.tensor_matrix_product(M)),
but can be much faster.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>y</strong><span class="classifier">Tensor</span></dt><dd><p>The second tensor of the inner product.</p>
</dd>
<dt><strong>M</strong><span class="classifier">list or numpy.ndarray or FullTensor</span></dt><dd><p>The weight matrix.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.float</dt><dd><p>The weighted inner product.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.eval_at_indices">
<code class="sig-name descname"><span class="pre">eval_at_indices</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ind</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.eval_at_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the tensor at indices.</p>
<p>If dims is None, return
s(k) = x(indices(k, 1), indices(k, 2), …, indices(k, d)),
1 &lt;= k &lt;= self.shape[0].</p>
<p>If dims is not None, return a partial evaluation: up to a permutation
(placing the dimensions dims on the left), return
s(k, i_1, …, i_d’) = x(indices(k, 1), indices(k, 2), …,
indices(k, M), i_1, …, i_d’),
1 &lt;= k &lt;= self.shape[0], with M = dims.size and d’ = self.order - M.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ind</strong><span class="classifier">list of numpy.ndarray</span></dt><dd><p>The indices of the tensor.</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list of numpy.ndarray, optional</span></dt><dd><p>The dimensions associated with the indices. The default is None,
indicating that indices refers to all the dimensions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>evaluations</strong><span class="classifier">scipy.sparse.lil.lil_matrix</span></dt><dd><p>The evaluations of the tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.eval_diag">
<code class="sig-name descname"><span class="pre">eval_diag</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.eval_diag" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract the diagonal of the tensor.</p>
<p>The tensor must be such that self.shape[mu] = n for all mu (in dims if
provided).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list of numpy.ndarray, optional</span></dt><dd><p>The dimensions associated with the indices of the diagonal. The
default is None,indicating that indices refers to all the
dimensions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>data</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>The evaluations of the diagonal of the tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.full">
<code class="sig-name descname"><span class="pre">full</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.full" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the SparseTensor to a tensap.FullTensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>y</strong><span class="classifier">tensap.FullTensor</span></dt><dd><p>The SparseTensor as a tensap.FullTensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.itranspose">
<code class="sig-name descname"><span class="pre">itranspose</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.itranspose" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the inverse transpose (permutation) of the dimensions of the
tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list or numpy.ndarray</span></dt><dd><p>The original transpose (permutation) indices.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>SparseTensor</dt><dd><p>The transposed (permuted) tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.kron">
<code class="sig-name descname"><span class="pre">kron</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.kron" title="Permalink to this definition">¶</a></dt>
<dd><p>Kronecker product of tensors.</p>
<p>Similar to numpy.kron but for sparse tensors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>y</strong><span class="classifier">Tensor</span></dt><dd><p>The second tensor of the Kronecker product.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>SparseTensor</dt><dd><p>The tensor resulting from the Kronecker product.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.ndim">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">ndim</span></code><a class="headerlink" href="#tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.ndim" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the order of the tensor. Equivalent to self.order.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>int</dt><dd><p>The order of the tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.norm">
<code class="sig-name descname"><span class="pre">norm</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the canonical norm of the SparseTensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>numpy.float</dt><dd><p>The norm of the tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.numpy">
<code class="sig-name descname"><span class="pre">numpy</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.numpy" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the SparseTensor to a scipy.sparse.lil.lil_matrix, which can
be converted to a numpy.matrix using the command todense().</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>y</strong><span class="classifier">scipy.sparse.lil.lil_matrix</span></dt><dd><p>The SparseTensor as a scipy.sparse.lil.lil_matrix.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.orth">
<code class="sig-name descname"><span class="pre">orth</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.orth" title="Permalink to this definition">¶</a></dt>
<dd><p>Orthogonalize the tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dim</strong><span class="classifier">int</span></dt><dd><p>The dimension of the orthogonal dim-matricization of self.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>SparseTensor</dt><dd><p>A tensor whose dim-matricization is an orthogonal matrix
corresponding to the Q factor of a QR factorization of the
dim-matricization of self.</p>
</dd>
<dt><strong>r_matrix</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>The R factor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.reshape">
<code class="sig-name descname"><span class="pre">reshape</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.reshape" title="Permalink to this definition">¶</a></dt>
<dd><p>Reshape the tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>shape</strong><span class="classifier">list or numpy.ndarray</span></dt><dd><p>The new shape of the tensor.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>tensor</strong><span class="classifier">SparseTensor</span></dt><dd><p>The reshaped tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.size">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">size</span></code><a class="headerlink" href="#tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the size of the tensor. Equivalent to self.storage().</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>The size of the tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.sparse_storage">
<code class="sig-name descname"><span class="pre">sparse_storage</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.sparse_storage" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sparse storage complexity of the SparseTensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>int</dt><dd><p>The sparse storage complexity of the SparseTensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.squeeze">
<code class="sig-name descname"><span class="pre">squeeze</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.squeeze" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the singleton dimensions of the tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list or numpy.ndarray, optional</span></dt><dd><p>Dimensions to squeeze. The default is None, indicating all the
singleton dimensions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>SparseTensor</dt><dd><p>The squeezed tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.storage">
<code class="sig-name descname"><span class="pre">storage</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.storage" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the storage complexity of the SparseTensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>int</dt><dd><p>The storage complexity of the SparseTensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.sub_tensor">
<code class="sig-name descname"><span class="pre">sub_tensor</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">indices</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.sub_tensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract a subtensor of the tensor.</p>
<p>The result is a tensor s of shape
len(indices[0]), …, len(indices[self.order-1]),
such that
s(k1,…,kd) = x(indices[0][k1], …, indices[self.order-1][kd]).</p>
<p>Example: x.subTensor([1, 2], ‘:’, [2, 5, 6]) returns a tensor with
shape [2, self.shape[1], 3].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>*indices</strong><span class="classifier">list</span></dt><dd><p>The indices to extract in each dimension. ‘:’ indicates all the
indices.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>SparseTensor</dt><dd><p>The subtensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.tensor_diagonal_matrix_product">
<code class="sig-name descname"><span class="pre">tensor_diagonal_matrix_product</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.tensor_diagonal_matrix_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Contract a SparseTensor with matrices built from their diagonals.</p>
<p>The second dimension of the matrix matrices[k] is contracted with the
k-th dimension of self, with the indices k given in dims (if provided).</p>
<p>FIXME: not optimal, does not exploit sparsity.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>matrices</strong><span class="classifier">numpy.ndarray or list of numpy.ndarray</span></dt><dd><p>The diagonals of the matrices to use in the product.</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list or numpy.ndarray, optional</span></dt><dd><p>Indices of the contractions. The default is None, indicating all
the dimensions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>SparseTensor</dt><dd><p>The tensor after the contractions with the matrices.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.tensor_matrix_product">
<code class="sig-name descname"><span class="pre">tensor_matrix_product</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.tensor_matrix_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Contract a tensor with matrices.</p>
<p>The second dimension of the matrix matrices[k] is contracted with the
k-th dimension of self, with the indices k given in dims (if provided).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>matrices</strong><span class="classifier">numpy.ndarray or list of numpy.ndarray</span></dt><dd><p>The matrices to use in the product.</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list or numpy.ndarray, optional</span></dt><dd><p>Indices of the contractions. The default is None, indicating all
the dimensions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">SparseTensor</span></dt><dd><p>The tensor after the contractions with the matrices.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.tensor_matrix_product_eval_diag">
<code class="sig-name descname"><span class="pre">tensor_matrix_product_eval_diag</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrices</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.tensor_matrix_product_eval_diag" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the diagonal of a tensor obtained by contraction with
matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>matrices</strong><span class="classifier">list</span></dt><dd><p>The matrices to use in the product.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>SparseTensor</dt><dd><p>The diagonal of the contractions of the tensor with the matrices.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.tensor_vector_product">
<code class="sig-name descname"><span class="pre">tensor_vector_product</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vectors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.tensor_vector_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the contraction of the tensor with vectors.</p>
<p>Compute the contraction of self with each vector contained in the list
vectors along dimensions specified by dims. The operation is such that
V[k] is contracted with the dims[k]-th dimension of self.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vectors</strong><span class="classifier">numpy.ndarray or list of numpy.ndarray</span></dt><dd><p>The vectors to use in the product.</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list or numpy.ndarray, optional</span></dt><dd><p>Indices of the contractions. The default is None, indicating all
the dimensions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">SparseTensor</span></dt><dd><p>The tensor after the contractions with the vectors.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.tensordot_matrix_product_except_dim">
<code class="sig-name descname"><span class="pre">tensordot_matrix_product_except_dim</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.tensordot_matrix_product_except_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Particular type of contraction.</p>
<p>Compute a special contraction of two tensors self, y, a list of
matrices M and a particular dimension dim. Note that dim must
be a scalar, while M must be a list array with x.self.order
elements.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>y</strong><span class="classifier">Tensor</span></dt><dd><p>The second tensor of the contraction.</p>
</dd>
<dt><strong>M</strong><span class="classifier">list</span></dt><dd><p>The list of matrices of the contraction.</p>
</dd>
<dt><strong>dim</strong><span class="classifier">int</span></dt><dd><p>The excluded dimension.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>The result of the contraction.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.transpose">
<code class="sig-name descname"><span class="pre">transpose</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.sparse_tensor.SparseTensor.transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>Transpose (permute) the dimensions of the tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list or numpy.ndarray</span></dt><dd><p>The new ordering of the dimensions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">SparseTensor</span></dt><dd><p>The transposed (permuted) tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-tensap.tensor_algebra.tensors.tree_based_tensor">
<span id="tensap-tensor-algebra-tensors-tree-based-tensor-module"></span><h2>tensap.tensor_algebra.tensors.tree_based_tensor module<a class="headerlink" href="#module-tensap.tensor_algebra.tensors.tree_based_tensor" title="Permalink to this headline">¶</a></h2>
<p>Module tree_based_tensor.</p>
<dl class="py class">
<dt id="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">tensap.tensor_algebra.tensors.tree_based_tensor.</span></code><code class="sig-name descname"><span class="pre">TreeBasedTensor</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cores</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tree</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Class TreeBasedTensor: algebraic tensors in tree-based tensor format.</p>
<p>References:
- Nouy, A. (2017). Low-rank methods for high-dimensional approximation
and model order reduction. Model reduction and approximation, P. Benner,
A. Cohen, M. Ohlberger, and K. Willcox, eds., SIAM, Philadelphia,
PA, 171-226.
- Falco, A., Hackbusch, W., &amp; Nouy, A. (2018). Tree-based tensor formats.
SeMA Journal, 1-15
- Grelier, E., Nouy, A., &amp; Chevreuil, M. (2018). Learning with tree-based
tensor formats. arXiv preprint arXiv:1811.04455
- Nouy, A. (2019). Higher-order principal component analysis for the
approximation of tensors in tree-based low-rank formats. Numerische
Mathematik, 141(3), 743-789</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tensors</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Parameters of the representation.</p>
</dd>
<dt><strong>ranks</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Tree-based rank.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int</span></dt><dd><p>Order of the tensor.</p>
</dd>
<dt><strong>shape</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Shape of the tensor.</p>
</dd>
<dt><strong>tree</strong><span class="classifier">tensap.DimensionTree</span></dt><dd><p>Dimension tree.</p>
</dd>
<dt><strong>is_orth</strong><span class="classifier">bool</span></dt><dd><p>True if the representation of the tensor is orthogonal.</p>
</dd>
<dt><strong>is_active_node</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Logical array indicating if the nodes are active.</p>
</dd>
<dt><strong>orth_node</strong><span class="classifier">int</span></dt><dd><p>Node with respect to which the representation is orthogonalized (0 is
the root node)</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.cat" title="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.cat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cat</span></code></a>(tensor2)</p></td>
<td><p>Concatenate the tensors.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.create" title="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.create"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create</span></code></a>(generator, tree[, ranks, shape, …])</p></td>
<td><p>Create a tree-based tensor from a generator.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.dot" title="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.dot"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dot</span></code></a>(tensor2)</p></td>
<td><p>Return the inner product of two tensors.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.dot_with_rank_one_metric" title="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.dot_with_rank_one_metric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dot_with_rank_one_metric</span></code></a>(tensor2, matrices)</p></td>
<td><p>Compute the weighted inner product of two tree-based tensors.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.eval_at_indices" title="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.eval_at_indices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval_at_indices</span></code></a>(indices[, dims])</p></td>
<td><p>Evaluate the tensor at indices.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.eval_diag" title="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.eval_diag"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval_diag</span></code></a>([dims, nargout])</p></td>
<td><p>Extract the diagonal of the tensor.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.eval_diag_above" title="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.eval_diag_above"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval_diag_above</span></code></a>([diag_below, alpha])</p></td>
<td><p>Evaluate the diagonal of the tensor of the function w^lpha of the representation f = sum_{k=1}^{beta} v^beta_k w^beta_k (optionally for the node alpha and its ascendants).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.eval_diag_below" title="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.eval_diag_below"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval_diag_below</span></code></a>([alpha, except_nodes])</p></td>
<td><p>Evaluate the diagonal of the tensor of the function v^beta of the representation f = sum_{k=1}^{beta} v^beta_k w^beta_k (optionally for all the nodes except the ascendants of a node alpha).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.full" title="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.full"><code class="xref py py-obj docutils literal notranslate"><span class="pre">full</span></code></a>()</p></td>
<td><p>Convert a TreeBasedTensor to a tensap.FullTensor</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.gramians" title="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.gramians"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gramians</span></code></a>([alpha])</p></td>
<td><p>Compute the Gram matrices of the bases of minimal subspaces associated with nodes of the tree.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.hadamard_product" title="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.hadamard_product"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hadamard_product</span></code></a>(arg)</p></td>
<td><p>Compute the Hadamard product of two tensors.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.inactivate_nodes" title="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.inactivate_nodes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">inactivate_nodes</span></code></a>(nodes)</p></td>
<td><p>Inactivate a list of nodes.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.is_active_dim" title="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.is_active_dim"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_active_dim</span></code></a>(dim)</p></td>
<td><p>Return an array containing true if the given dimensions are active, false otherwise.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.is_admissible_rank" title="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.is_admissible_rank"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_admissible_rank</span></code></a>([ranks, nargout])</p></td>
<td><p>Check if a given tuple is an admissible tree-based rank.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.kron" title="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.kron"><code class="xref py py-obj docutils literal notranslate"><span class="pre">kron</span></code></a>(tensor2)</p></td>
<td><p>Kronecker product of tensors.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.nodes_permutation_cost" title="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.nodes_permutation_cost"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nodes_permutation_cost</span></code></a>(alpha)</p></td>
<td><p>Cost of the permutation of a given node alpha with the other nodes of the dimension tree.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.norm" title="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.norm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">norm</span></code></a>()</p></td>
<td><p>Compute the canonical norm of the tensor.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.numpy" title="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.numpy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span></code></a>()</p></td>
<td><p>Convert the TreeBasedTensor to a numpy.ndarray.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.ones" title="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.ones"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ones</span></code></a>(tree[, ranks, shape, is_active_node])</p></td>
<td><p>Create a tensor of shape shape and tree-based rank ranks with node tensors generated with the method ones of numpy.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.optimize_dimension_tree" title="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.optimize_dimension_tree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">optimize_dimension_tree</span></code></a>(tolerance, max_iter)</p></td>
<td><p>Optimization over the set of trees to obtain a representation of the tensor with lower complexity.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.optimize_leaves_permutations" title="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.optimize_leaves_permutations"><code class="xref py py-obj docutils literal notranslate"><span class="pre">optimize_leaves_permutations</span></code></a>(tolerance, max_iter)</p></td>
<td><p>Optimization over the ordering of the leaves of the tree to obtain a representation of the tensor with lower complexity.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.orth" title="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.orth"><code class="xref py py-obj docutils literal notranslate"><span class="pre">orth</span></code></a>()</p></td>
<td><p>Orthogonalize the representation of the tensor.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.orth_at_node" title="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.orth_at_node"><code class="xref py py-obj docutils literal notranslate"><span class="pre">orth_at_node</span></code></a>(nod)</p></td>
<td><p>Orthogonalize the representation with respect to a given node.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.parameter_gradient_eval_diag" title="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.parameter_gradient_eval_diag"><code class="xref py py-obj docutils literal notranslate"><span class="pre">parameter_gradient_eval_diag</span></code></a>(alpha[, matrices])</p></td>
<td><p>Compute the diagonal of the gradient of the tensor with respect to a given parameter.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.parameter_gradient_eval_diag_dmrg" title="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.parameter_gradient_eval_diag_dmrg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">parameter_gradient_eval_diag_dmrg</span></code></a>(alpha[, …])</p></td>
<td><p>Return the diagonal of the gradient of the tensor with respect to a given parameter, obtained by contraction of two node tensors along their common edge; used in a DMRG algorithm.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.permute_leaves" title="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.permute_leaves"><code class="xref py py-obj docutils literal notranslate"><span class="pre">permute_leaves</span></code></a>(perm[, tolerance])</p></td>
<td><p>Permutation of leaf nodes given a permutation of the dimensions.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.permute_nodes" title="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.permute_nodes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">permute_nodes</span></code></a>(nodes[, tolerance])</p></td>
<td><p>Permutation of two nodes of the tree.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.plot" title="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.plot"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot</span></code></a>([nodes_labels, title])</p></td>
<td><p>Plot the tree with the nodes indices and the active nodes.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.rand" title="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.rand"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rand</span></code></a>(tree[, ranks, shape, is_active_node])</p></td>
<td><p>Create a tensor of shape shape and tree-based rank ranks with node tensors generated with the method random.rand of numpy.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.randn" title="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.randn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">randn</span></code></a>(tree[, ranks, shape, is_active_node])</p></td>
<td><p>Create a tensor of shape shape and tree-based rank ranks with node tensors generated with the method random.randn of numpy.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.remove_unique_children" title="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.remove_unique_children"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_unique_children</span></code></a>()</p></td>
<td><p>Remove the unique children of a tree-based tensor (nodes with no siblings in the tree).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.singular_values" title="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.singular_values"><code class="xref py py-obj docutils literal notranslate"><span class="pre">singular_values</span></code></a>()</p></td>
<td><p>Compute the tree-based singular values of a tensor, which are the singular values associated with alpha-matricizations of the tensor, for all alpha in the dimension tree.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.sparse_leaves_storage" title="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.sparse_leaves_storage"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sparse_leaves_storage</span></code></a>()</p></td>
<td><p>Return the storage complexity of the TreeBasedTensor taking into account the sparsity in the leaves.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.sparse_storage" title="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.sparse_storage"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sparse_storage</span></code></a>()</p></td>
<td><p>Return the sparse storage complexity of the TreeBasedTensor.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.squeeze" title="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.squeeze"><code class="xref py py-obj docutils literal notranslate"><span class="pre">squeeze</span></code></a>([dims])</p></td>
<td><p>Remove the singleton dimensions of the tensor.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.storage" title="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.storage"><code class="xref py py-obj docutils literal notranslate"><span class="pre">storage</span></code></a>()</p></td>
<td><p>Return the storage complexity of the TreeBasedTensor.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.sub_tensor" title="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.sub_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sub_tensor</span></code></a>(*indices)</p></td>
<td><p>Extract a subtensor of the tensor.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.tensor_diagonal_matrix_product" title="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.tensor_diagonal_matrix_product"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tensor_diagonal_matrix_product</span></code></a>(matrices[, dims])</p></td>
<td><p>Contract a TreeBasedTensor with matrices built from their diagonals.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.tensor_matrix_product" title="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.tensor_matrix_product"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tensor_matrix_product</span></code></a>(matrices[, dims])</p></td>
<td><p>Contract a tensor with matrices.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.tensor_matrix_product_eval_diag" title="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.tensor_matrix_product_eval_diag"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tensor_matrix_product_eval_diag</span></code></a>(matrices[, dims])</p></td>
<td><p>Evaluate the diagonal of a tensor obtained by contraction with matrices.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.tensor_train" title="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.tensor_train"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tensor_train</span></code></a>(cores[, dims])</p></td>
<td><p>Create a tree-based tensor with a tensor-train structure.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.tensor_vector_product" title="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.tensor_vector_product"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tensor_vector_product</span></code></a>(vectors[, dims])</p></td>
<td><p>Compute the contraction of the tensor with vectors.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.tensordot_matrix_product_except_dim" title="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.tensordot_matrix_product_except_dim"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tensordot_matrix_product_except_dim</span></code></a>(tensor2, …)</p></td>
<td><p>Particular type of contraction.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.update_attributes" title="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.update_attributes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">update_attributes</span></code></a>()</p></td>
<td><p>Update the attributes of the TreeBasedTensor.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.zeros" title="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.zeros"><code class="xref py py-obj docutils literal notranslate"><span class="pre">zeros</span></code></a>(tree[, ranks, shape, is_active_node])</p></td>
<td><p>Create a tensor of shape shape and tree-based rank ranks with node tensors generated with the method zeros of numpy.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.active_dims">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">active_dims</span></code><a class="headerlink" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.active_dims" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of active dimensions.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>The list of active dimensions.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.active_nodes">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">active_nodes</span></code><a class="headerlink" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.active_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of active nodes.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>The list of active nodes.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.cat">
<code class="sig-name descname"><span class="pre">cat</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensor2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.cat" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenate the tensors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tensor2</strong><span class="classifier">TreeBasedTensor</span></dt><dd><p>The second tensor to be concatenated.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>tensor</strong><span class="classifier">TreeBasedTensor</span></dt><dd><p>The concatenated tensors.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.create">
<em class="property"><span class="pre">static</span> </em><code class="sig-name descname"><span class="pre">create</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">generator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tree</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ranks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_active_node</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a tree-based tensor from a generator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>generator</strong><span class="classifier">function</span></dt><dd><p>Function generating a tensap.FullTensor, given a shape.</p>
</dd>
<dt><strong>tree</strong><span class="classifier">tensap.FullTensor</span></dt><dd><p>The tensap.FullTensor of the TreeBasedTensor.</p>
</dd>
<dt><strong>ranks</strong><span class="classifier">numpy.ndarray, list or ‘random’, optional</span></dt><dd><p>Ranks of the TreeBasedTensorFormat. The default is None, generating
random ranks between 1 and 5.</p>
</dd>
<dt><strong>shape</strong><span class="classifier">numpy.ndarray, list or ‘random’, optional</span></dt><dd><p>The size of the spaces of the leaves of the tree. The default is
None, assigning ranks to shape.</p>
</dd>
<dt><strong>is_active_node</strong><span class="classifier">numpy.ndarray, list or ‘random’, optional</span></dt><dd><p>Booleans indicating if the node is active. The default is None, for
which all the nodes are active.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>TreeBasedTensor</dt><dd><p>A TreeBasedTensor with the input characteristics.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If some internal nodes are inactive.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.dot">
<code class="sig-name descname"><span class="pre">dot</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensor2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the inner product of two tensors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tensor2</strong><span class="classifier">TreeBasedTensor</span></dt><dd><p>The second tensor of the inner products.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.float</dt><dd><p>The inner product of the two tensors.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.dot_with_rank_one_metric">
<code class="sig-name descname"><span class="pre">dot_with_rank_one_metric</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensor2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">matrices</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.dot_with_rank_one_metric" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the weighted inner product of two tree-based tensors.</p>
<p>Compute the weighted canonical inner product of self and tensor2,
where the inner product related to dimension k is weighted by
matrix[k]. It is equivalent to
self.dot(tensor2.tensor_matrix_product(matrix)),
but can be much faster.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tensor2</strong><span class="classifier">TreeBasedTensor</span></dt><dd><p>The second tensor of the inner product.</p>
</dd>
<dt><strong>matrix</strong><span class="classifier">list or numpy.ndarray</span></dt><dd><p>The weight matrices.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.float</dt><dd><p>The weighted inner product.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.eval_at_indices">
<code class="sig-name descname"><span class="pre">eval_at_indices</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.eval_at_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the tensor at indices.</p>
<p>If dims is None, return
s(k) = x(indices(k, 1), indices(k, 2), …, indices(k, d)),
1 &lt;= k &lt;= self.shape[0].</p>
<p>If dims is not None, return a partial evaluation: up to a permutation
(placing the dimensions dims on the left), return
s(k, i_1, …, i_d’) = x(indices(k, 1), indices(k, 2), …,
indices(k, M), i_1, …, i_d’),
1 &lt;= k &lt;= self.shape[0], with M = dims.size and d’ = self.order - M.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>indices</strong><span class="classifier">list of numpy.ndarray</span></dt><dd><p>The indices of the tensor.</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list of numpy.ndarray, optional</span></dt><dd><p>The dimensions associated with the indices. The default is None,
indicating that indices refers to all the dimensions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>evaluations</strong><span class="classifier">numpy.ndarray or TreeBasedTensor</span></dt><dd><p>The evaluations of the tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.eval_diag">
<code class="sig-name descname"><span class="pre">eval_diag</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nargout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.eval_diag" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract the diagonal of the tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nargout</strong><span class="classifier">int, optional</span></dt><dd><p>The number of outputs. The default is 1, returning the diagonal.
If set to 2, return the node tensors with their diagonal evaluated
as well.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.array or (numpy.array and list)</dt><dd><p>The diagonal and, if nargout == 2, the node tensors with their
diagonal evaluated.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.eval_diag_above">
<code class="sig-name descname"><span class="pre">eval_diag_above</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">diag_below</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.eval_diag_above" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the diagonal of the tensor of the function w^lpha of the
representation
f = sum_{k=1}^{beta} v^beta_k w^beta_k
(optionally for the node alpha and its ascendants).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>diag_below</strong><span class="classifier">numpy.ndarray, optional</span></dt><dd><p>The result of the method eval_diag_below. The default is None,
calling the method eval_diag_below.</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">int, optional</span></dt><dd><p>A node of the tree, including it and its ascendants in the
computation of the functions w^beta. The default is None,
indicating that all the nodes are included.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>diag_above</strong><span class="classifier">numpy.ndarray or tensap.FullTensor</span></dt><dd><p>The diagonals of the tensor of the functions w^beta for the
included nodes, and None for the excluded nodes.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.eval_diag_below">
<code class="sig-name descname"><span class="pre">eval_diag_below</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">except_nodes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.eval_diag_below" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the diagonal of the tensor of the function v^beta of the
representation
f = sum_{k=1}^{beta} v^beta_k w^beta_k
(optionally for all the nodes except the ascendants of a node alpha).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>alpha</strong><span class="classifier">int, optional</span></dt><dd><p>A node of the tree, exluding its ascendants in the computation of
the functions v^beta. The default is None, indicating that no
node is excluded.</p>
</dd>
<dt><strong>except_nodes</strong><span class="classifier">int or list or numpy.array, optional</span></dt><dd><p>Nodes for which the computation is not performed. The default is
None.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>diag_below</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>An array containing the diagonals of the tensor of the functions
v^beta for the included nodes, and None for the excluded nodes.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.full">
<code class="sig-name descname"><span class="pre">full</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.full" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a TreeBasedTensor to a tensap.FullTensor</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tensor</strong><span class="classifier">tensap.FullTensor</span></dt><dd><p>A representation of the TreeBasedTensor as a tensap.FullTensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.gramians">
<code class="sig-name descname"><span class="pre">gramians</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.gramians" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Gram matrices of the bases of minimal subspaces associated
with nodes of the tree.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>alpha</strong><span class="classifier">list or numpy.ndarray, optional</span></dt><dd><p>The nodes associated to the Gram matrices to be computed. The
default is None, for all the nodes of the tree.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>gram</strong><span class="classifier">list</span></dt><dd><p>The Gram matrices.</p>
</dd>
<dt>TreeBasedTensor</dt><dd><p>The orthogonalized TreeBasedTensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.hadamard_product">
<code class="sig-name descname"><span class="pre">hadamard_product</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arg</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.hadamard_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Hadamard product of two tensors.</p>
<p>Equivalent to self * arg.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>arg</strong><span class="classifier">TreeBasedTensor</span></dt><dd><p>The second tensor of the Hadamard product.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>tensap.FullTensor</dt><dd><p>The tensor resulting from the Hadamard product.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.inactivate_nodes">
<code class="sig-name descname"><span class="pre">inactivate_nodes</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nodes</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.inactivate_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Inactivate a list of nodes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nodes</strong><span class="classifier">list or numpy.ndarray</span></dt><dd><p>The list of nodes to inactivate.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>TreeBasedTensor</dt><dd><p>The tensor with inactivated nodes.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.is_active_dim">
<code class="sig-name descname"><span class="pre">is_active_dim</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.is_active_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array containing true if the given dimensions are active,
false otherwise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dim</strong><span class="classifier">integer</span></dt><dd><p>The tested dimension.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">numpy.ndarray or boolean</span></dt><dd><p>Array containing true if the given dimensions are active, false
otherwise.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.is_admissible_rank">
<code class="sig-name descname"><span class="pre">is_admissible_rank</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ranks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nargout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.is_admissible_rank" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if a given tuple is an admissible tree-based rank.</p>
<p>If no tree-based rank is provided, the tree-based rank of self is
checked.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ranks</strong><span class="classifier">typle of numpy.ndarray, optional</span></dt><dd><p>The tree-based rank to be checked. The default is None, indicating
the tree-based rank of self.</p>
</dd>
<dt><strong>nargout</strong><span class="classifier">int, optional</span></dt><dd><p>Indicates the number of expected outputs. The default is 1,
indicating to return only the boolean characterizing if the
tree-based rank is admissible.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>is_admiss</strong><span class="classifier">bool</span></dt><dd><p>True if the tree-based rank is admissible.</p>
</dd>
<dt><strong>ch_admiss</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Array detailing the admissibility of the children ranks.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.kron">
<code class="sig-name descname"><span class="pre">kron</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensor2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.kron" title="Permalink to this definition">¶</a></dt>
<dd><p>Kronecker product of tensors.</p>
<p>Similar to numpy.kron but for tree-based tensors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tensor2</strong><span class="classifier">TreeBasedTensor</span></dt><dd><p>The second tensor of the Kronecker product.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>tensor</strong><span class="classifier">TreeBasedTensor</span></dt><dd><p>The tensor resulting from the Kronecker product.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.ndim">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">ndim</span></code><a class="headerlink" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.ndim" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the order of the tensor. Equivalent to self.order.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>int</dt><dd><p>The order of the tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.nodes_permutation_cost">
<code class="sig-name descname"><span class="pre">nodes_permutation_cost</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.nodes_permutation_cost" title="Permalink to this definition">¶</a></dt>
<dd><p>Cost of the permutation of a given node alpha with the other nodes of
the dimension tree.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>alpha</strong><span class="classifier">int</span></dt><dd><p>The node from which all the permutation costs are computed.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>cost</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>The cost of permuting alpha with the other nodes of the tree.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.non_active_dims">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">non_active_dims</span></code><a class="headerlink" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.non_active_dims" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of non active dimensions.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>The list of active dimensions.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.non_active_nodes">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">non_active_nodes</span></code><a class="headerlink" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.non_active_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of non active nodes.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>The list of non active nodes.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.norm">
<code class="sig-name descname"><span class="pre">norm</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the canonical norm of the tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>numpy.float</dt><dd><p>The norm of the tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.numpy">
<code class="sig-name descname"><span class="pre">numpy</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.numpy" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the TreeBasedTensor to a numpy.ndarray.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>The TreeBasedTensor as a numpy.ndarray.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.ones">
<em class="property"><span class="pre">static</span> </em><code class="sig-name descname"><span class="pre">ones</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tree</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ranks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_active_node</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.ones" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a tensor of shape shape and tree-based rank ranks with node
tensors generated with the method ones of numpy.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tree</strong><span class="classifier">tensap.FullTensor</span></dt><dd><p>The tensap.FullTensor of the TreeBasedTensor.</p>
</dd>
<dt><strong>ranks</strong><span class="classifier">numpy.ndarray, list or ‘random’, optional</span></dt><dd><p>Ranks of the TreeBasedTensorFormat. The default is None, generating
random ranks between 1 and 5.</p>
</dd>
<dt><strong>shape</strong><span class="classifier">numpy.ndarray, list or ‘random’, optional</span></dt><dd><p>The size of the spaces of the leaves of the tree. The default is
None, assigning ranks to shape.</p>
</dd>
<dt><strong>is_active_node</strong><span class="classifier">numpy.ndarray, list or ‘random’, optional</span></dt><dd><p>Booleans indicating if the node is active. The default is None, for
which all the nodes are active.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>TreeBasedTensor</dt><dd><p>A TreeBasedTensor with the input characteristics.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.optimize_dimension_tree">
<code class="sig-name descname"><span class="pre">optimize_dimension_tree</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tolerance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.optimize_dimension_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimization over the set of trees to obtain a representation of the
tensor with lower complexity.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tolerance</strong><span class="classifier">float</span></dt><dd><p>The relative tolerance for the tree changes.</p>
</dd>
<dt><strong>max_iter</strong><span class="classifier">int</span></dt><dd><p>The maximum number of tree changes.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>tensor_star</strong><span class="classifier">tensap.TreeBasedTensor</span></dt><dd><p>The tree-based tensor with optimized tree.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.optimize_leaves_permutations">
<code class="sig-name descname"><span class="pre">optimize_leaves_permutations</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tolerance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.optimize_leaves_permutations" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimization over the ordering of the leaves of the tree to obtain a
representation of the tensor with lower complexity.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tolerance</strong><span class="classifier">float</span></dt><dd><p>The relative tolerance for the tree changes.</p>
</dd>
<dt><strong>max_iter</strong><span class="classifier">int</span></dt><dd><p>The maximum number of tree changes.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>tensor_star</strong><span class="classifier">tensap.TreeBasedTensor</span></dt><dd><p>The tree-based tensor with optimized leaves ordering.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.orth">
<code class="sig-name descname"><span class="pre">orth</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.orth" title="Permalink to this definition">¶</a></dt>
<dd><p>Orthogonalize the representation of the tensor.</p>
<p>All core tensors except the root core represents orthonormal bases of
principal subspaces.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tensor</strong><span class="classifier">TreeBasedTensor</span></dt><dd><p>The TreeBasedTensor with an orthogonal representation.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.orth_at_node">
<code class="sig-name descname"><span class="pre">orth_at_node</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nod</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.orth_at_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Orthogonalize the representation with respect to a given node.</p>
<p>All core tensors except the one of node nod represents orthonormal
bases of principal subspaces. The core tensor of node nod is such that
the tensor x(i_alpha,i_alpha^c) = sum_k u_k(i_alpha) w_k(i_alpha^c),
where w_k is a set of orthonormal vectors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nod</strong><span class="classifier">int</span></dt><dd><p>The node with respect to which the representation is orthogonal.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>tensor</strong><span class="classifier">TreeBasedTensor</span></dt><dd><p>The TreeBasedTensor with an orthogonal representation.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If nod is non active.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.parameter_gradient_eval_diag">
<code class="sig-name descname"><span class="pre">parameter_gradient_eval_diag</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">matrices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.parameter_gradient_eval_diag" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the diagonal of the gradient of the tensor with respect to a
given parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>alpha</strong><span class="classifier">int</span></dt><dd><p>Index of node of the dimension tree.</p>
</dd>
<dt><strong>matrices</strong><span class="classifier">list or numpy.array, optional</span></dt><dd><p>Matrices with which to compute outer_product_eval_diag if alpha is
associated with some dimensions. Useful for evaluating the gradient
of a tensap.FunctionalTensor. The default is None, indicating
identity matrices.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">tensap.FullTensor</span></dt><dd><p>The diagonal of the gradient of the tensor with respect to
self.tensors[alpha-1].</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.parameter_gradient_eval_diag_dmrg">
<code class="sig-name descname"><span class="pre">parameter_gradient_eval_diag_dmrg</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">matrices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.parameter_gradient_eval_diag_dmrg" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the diagonal of the gradient of the tensor with respect to a
given parameter, obtained by contraction of two node tensors along
their common edge; used in a DMRG algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>alpha</strong><span class="classifier">int</span></dt><dd><p>Index of node of the dimension tree.</p>
</dd>
<dt><strong>matrices</strong><span class="classifier">list or numpy.array, optional</span></dt><dd><p>Matrices with which to compute outer_product_eval_diag if alpha is
associated with some dimensions. Useful for evaluating the gradient
of a tensap.FunctionalTensor. The default is None, indicating
identity matrices.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">tensap.FullTensor</span></dt><dd><p>The diagonal of the gradient of the tensor with respect to the
parameter.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.permute_leaves">
<code class="sig-name descname"><span class="pre">permute_leaves</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">perm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-15</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.permute_leaves" title="Permalink to this definition">¶</a></dt>
<dd><p>Permutation of leaf nodes given a permutation of the dimensions.</p>
<p>Permutations of the leaf nodes given a permutation perm of the
dimensions and a tolerance (for SVD-based truncations).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>perm</strong><span class="classifier">list or numpy.ndarray</span></dt><dd><p>Permutation of (1,…,self.order).</p>
</dd>
<dt><strong>tolerance</strong><span class="classifier">float, optional</span></dt><dd><p>Relative precision for SVD truncations. The default is 1e-15.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>tensor</strong><span class="classifier">tensap.TreeBasedTensor</span></dt><dd><p>The tree-based tensor with permuted leaf nodes.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.permute_nodes">
<code class="sig-name descname"><span class="pre">permute_nodes</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nodes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-15</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.permute_nodes" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Permutation of two nodes of the tree.</p>
</div></blockquote>
<p>Permutations of the two nodes in nodes given a tolerance tol (for
SVD-based truncations).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nodes</strong><span class="classifier">list or numpy.ndarray</span></dt><dd><p>The two nodes to permute.</p>
</dd>
<dt><strong>tolerance</strong><span class="classifier">float, optional</span></dt><dd><p>Relative precision for SVD truncations. The default is 1e-15.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>tensor</strong><span class="classifier">tensap.TreeBasedTensor</span></dt><dd><p>The tree-based tensor with permuted nodes.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If the first node to permute is an ascendant or a descendant of the
second node to permute.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.plot">
<code class="sig-name descname"><span class="pre">plot</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nodes_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the tree with the nodes indices and the active nodes.</p>
<p>This method requires the package igraph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nodes_labels</strong><span class="classifier">list or numpy.ndarray, optional</span></dt><dd><p>The labels of the nodes. The default is None, displaying the
nodes numbers.</p>
</dd>
<dt><strong>title</strong><span class="classifier">str, optional</span></dt><dd><p>The title of the graph. The default is None.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.rand">
<em class="property"><span class="pre">static</span> </em><code class="sig-name descname"><span class="pre">rand</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tree</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ranks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_active_node</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.rand" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a tensor of shape shape and tree-based rank ranks with node
tensors generated with the method random.rand of numpy.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tree</strong><span class="classifier">tensap.FullTensor</span></dt><dd><p>The tensap.FullTensor of the TreeBasedTensor.</p>
</dd>
<dt><strong>ranks</strong><span class="classifier">numpy.ndarray, list or ‘random’, optional</span></dt><dd><p>Ranks of the TreeBasedTensorFormat. The default is None, generating
random ranks between 1 and 5.</p>
</dd>
<dt><strong>shape</strong><span class="classifier">numpy.ndarray, list or ‘random’, optional</span></dt><dd><p>The size of the spaces of the leaves of the tree. The default is
None, assigning ranks to shape.</p>
</dd>
<dt><strong>is_active_node</strong><span class="classifier">numpy.ndarray, list or ‘random’, optional</span></dt><dd><p>Booleans indicating if the node is active. The default is None, for
which all the nodes are active.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>TreeBasedTensor</dt><dd><p>A TreeBasedTensor with the input characteristics.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.randn">
<em class="property"><span class="pre">static</span> </em><code class="sig-name descname"><span class="pre">randn</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tree</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ranks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_active_node</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.randn" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a tensor of shape shape and tree-based rank ranks with node
tensors generated with the method random.randn of numpy.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tree</strong><span class="classifier">tensap.FullTensor</span></dt><dd><p>The tensap.FullTensor of the TreeBasedTensor.</p>
</dd>
<dt><strong>ranks</strong><span class="classifier">numpy.ndarray, list or ‘random’, optional</span></dt><dd><p>Ranks of the TreeBasedTensorFormat. The default is None, generating
random ranks between 1 and 5.</p>
</dd>
<dt><strong>shape</strong><span class="classifier">numpy.ndarray, list or ‘random’, optional</span></dt><dd><p>The size of the spaces of the leaves of the tree. The default is
None, assigning ranks to shape.</p>
</dd>
<dt><strong>is_active_node</strong><span class="classifier">numpy.ndarray, list or ‘random’, optional</span></dt><dd><p>Booleans indicating if the node is active. The default is None, for
which all the nodes are active.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>TreeBasedTensor</dt><dd><p>A TreeBasedTensor with the input characteristics.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.rank">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">rank</span></code><a class="headerlink" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.rank" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the tree-based rank of the tensor (computed by SVD).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>The tree-based rank of the tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.remove_unique_children">
<code class="sig-name descname"><span class="pre">remove_unique_children</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.remove_unique_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the unique children of a tree-based tensor (nodes with no
siblings in the tree).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>TreeBasedTensor</dt><dd><p>The tensor with no unique children.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.representation_rank">
<em class="property"><span class="pre">property</span> </em><code class="sig-name descname"><span class="pre">representation_rank</span></code><a class="headerlink" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.representation_rank" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the representation tree-based rank of the tensor.</p>
<p>Corresponds to self.ranks.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>The representation tree-based rank of the tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.singular_values">
<code class="sig-name descname"><span class="pre">singular_values</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.singular_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the tree-based singular values of a tensor, which are the
singular values associated with alpha-matricizations of the tensor,
for all alpha in the dimension tree.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>The tree-based singular values of the tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.sparse_leaves_storage">
<code class="sig-name descname"><span class="pre">sparse_leaves_storage</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.sparse_leaves_storage" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the storage complexity of the TreeBasedTensor taking into
account the sparsity in the leaves.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>int</dt><dd><p>The storage complexity of the TreeBasedTensor taking into account
the sparsity in the leaves.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.sparse_storage">
<code class="sig-name descname"><span class="pre">sparse_storage</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.sparse_storage" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sparse storage complexity of the TreeBasedTensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>int</dt><dd><p>The sparse storage complexity of the TreeBasedTensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.squeeze">
<code class="sig-name descname"><span class="pre">squeeze</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.squeeze" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the singleton dimensions of the tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list or numpy.ndarray, optional</span></dt><dd><p>Dimensions to squeeze. The default is None, indicating all the
singleton dimensions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>TreeBasedTensor</dt><dd><p>The squeezed tensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.storage">
<code class="sig-name descname"><span class="pre">storage</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.storage" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the storage complexity of the TreeBasedTensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>int</dt><dd><p>The storage complexity of the TreeBasedTensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.sub_tensor">
<code class="sig-name descname"><span class="pre">sub_tensor</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">indices</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.sub_tensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract a subtensor of the tensor.</p>
<p>The result is a tensor s of shape
len(indices[0]), …, len(indices[self.order-1]),
such that
s(k1,…,kd) = x(indices[0][k1], …, indices[self.order-1][kd]).</p>
<p>Example: x.subTensor([1, 2], ‘:’, [2, 5, 6]) returns a tensor with
shape [2, self.shape[1], 3].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>*indices</strong><span class="classifier">list</span></dt><dd><p>The indices to extract in each dimension. ‘:’ indicates all the
indices.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>TreeaBasedTensor</dt><dd><p>The subtensor.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.tensor_diagonal_matrix_product">
<code class="sig-name descname"><span class="pre">tensor_diagonal_matrix_product</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.tensor_diagonal_matrix_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Contract a TreeBasedTensor with matrices built from their diagonals.</p>
<p>The second dimension of the matrix matrices[k] is contracted with the
k-th dimension of self, with the indices k given in dims (if provided).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>matrices</strong><span class="classifier">numpy.ndarray or list of numpy.ndarray</span></dt><dd><p>The diagonals of the matrices to use in the product.</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list or numpy.ndarray, optional</span></dt><dd><p>Indices of the contractions. The default is None, indicating all
the dimensions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>TreeBasedTensor</dt><dd><p>The tensor after the contractions with the matrices.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.tensor_matrix_product">
<code class="sig-name descname"><span class="pre">tensor_matrix_product</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.tensor_matrix_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Contract a tensor with matrices.</p>
<p>The second dimension of the matrix matrices[k] is contracted with the
k-th dimension of self, with the indices k given in dims (if provided).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>matrices</strong><span class="classifier">numpy.ndarray or list of numpy.ndarray</span></dt><dd><p>The matrices to use in the product.</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list or numpy.ndarray, optional</span></dt><dd><p>Indices of the contractions. The default is None, indicating all
the dimensions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>TreeBasedTensor</dt><dd><p>The tensor after the contractions with the matrices.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.tensor_matrix_product_eval_diag">
<code class="sig-name descname"><span class="pre">tensor_matrix_product_eval_diag</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.tensor_matrix_product_eval_diag" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the diagonal of a tensor obtained by contraction with
matrices.</p>
<p>Provides the diagonal of the tensor obtained by contracting the tensor
with matrices H[k] along dimensions dims(k)+1, for k = 0, …,
dims.size-1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>matrices</strong><span class="classifier">list</span></dt><dd><p>The matrices to use in the product.</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list or numpy.ndarray, optional</span></dt><dd><p>Indices of the contractions. The default is None, indicating all
the dimensions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">tensap.FullTensor</span></dt><dd><p>The result of the contractions of the tensor with the matrices.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.tensor_train">
<em class="property"><span class="pre">static</span> </em><code class="sig-name descname"><span class="pre">tensor_train</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cores</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.tensor_train" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a tree-based tensor with a tensor-train structure.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>cores</strong><span class="classifier">list or numpy.ndarray</span></dt><dd><p>List of tensap.FullTensor, each associated with one dimension.</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list or numpy.ndarray, optional</span></dt><dd><p>Dimension associated with each core. The default is
None, indicating that the i-th core is associated with the
dimension (i-1).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>tensap.TreeBasedTensor</dt><dd><p>The tree-based tensor with a tensor-train structure.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.tensor_vector_product">
<code class="sig-name descname"><span class="pre">tensor_vector_product</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vectors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.tensor_vector_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the contraction of the tensor with vectors.</p>
<p>Compute the contraction of self with each vector contained in the list
vectors along dimensions specified by dims. The operation is such that
V[k] is contracted with the dims[k]-th dimension of self.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vectors</strong><span class="classifier">numpy.ndarray or list of numpy.ndarray</span></dt><dd><p>The vectors to use in the product.</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list or numpy.ndarray, optional</span></dt><dd><p>Indices of the contractions. The default is None, indicating all
the dimensions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>TreeBasedTensor</dt><dd><p>The tensor after the contractions with the vectors.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.tensordot_matrix_product_except_dim">
<code class="sig-name descname"><span class="pre">tensordot_matrix_product_except_dim</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensor2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">matrices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.tensordot_matrix_product_except_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Particular type of contraction.</p>
<p>Compute a special contraction of two tensors self, tensor2, a list of
matrices matrices and a particular dimension dim. Note that dim must
be a scalar, while matrices must be a list array with x.self.order
elements.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tensor2</strong><span class="classifier">TreeBasedTensor</span></dt><dd><p>The second tensor of the contraction.</p>
</dd>
<dt><strong>matrices</strong><span class="classifier">list</span></dt><dd><p>The list of matrices of the contraction.</p>
</dd>
<dt><strong>dim</strong><span class="classifier">int</span></dt><dd><p>The excluded dimension.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>The result of the contraction.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.update_attributes">
<code class="sig-name descname"><span class="pre">update_attributes</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.update_attributes" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the attributes of the TreeBasedTensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>TreeBasedTensor</dt><dd><p>A TreeBasedTensor with updated attributes.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.zeros">
<em class="property"><span class="pre">static</span> </em><code class="sig-name descname"><span class="pre">zeros</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tree</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ranks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_active_node</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tensap.tensor_algebra.tensors.tree_based_tensor.TreeBasedTensor.zeros" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a tensor of shape shape and tree-based rank ranks with node
tensors generated with the method zeros of numpy.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tree</strong><span class="classifier">tensap.FullTensor</span></dt><dd><p>The tensap.FullTensor of the TreeBasedTensor.</p>
</dd>
<dt><strong>ranks</strong><span class="classifier">numpy.ndarray, list or ‘random’, optional</span></dt><dd><p>Ranks of the TreeBasedTensorFormat. The default is None, generating
random ranks between 1 and 5.</p>
</dd>
<dt><strong>shape</strong><span class="classifier">numpy.ndarray, list or ‘random’, optional</span></dt><dd><p>The size of the spaces of the leaves of the tree. The default is
None, assigning ranks to shape.</p>
</dd>
<dt><strong>is_active_node</strong><span class="classifier">numpy.ndarray, list or ‘random’, optional</span></dt><dd><p>Booleans indicating if the node is active. The default is None, for
which all the nodes are active.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>TreeBasedTensor</dt><dd><p>A TreeBasedTensor with the input characteristics.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-tensap.tensor_algebra.tensors">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-tensap.tensor_algebra.tensors" title="Permalink to this headline">¶</a></h2>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">tensap</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="bibliography.html">Bibliography</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="api.html">API documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="api.html#indices-and-tables">Indices and tables</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  <li><a href="api.html">API documentation</a><ul>
  <li><a href="tensap.tensor_algebra.html">tensap.tensor_algebra package</a><ul>
      <li>Previous: <a href="tensap.tensor_algebra.html" title="previous chapter">tensap.tensor_algebra package</a></li>
      <li>Next: <a href="tensap.tensor_algebra.tools.html" title="next chapter">tensap.tensor_algebra.tools package</a></li>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, A. Nouy, E. Grelier.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.5.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/tensap.tensor_algebra.tensors.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>